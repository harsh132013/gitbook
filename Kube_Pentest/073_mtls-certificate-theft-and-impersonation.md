
# Kubernetes mTLS Certificate Theft and Impersonation Vulnerability

## 1. Overview

This document outlines the vulnerability of mTLS certificate theft and impersonation in a Kubernetes environment. This vulnerability allows an attacker to gain unauthorized access to the Kubernetes API server and perform actions as the compromised user or service account.

### Attack Vector Description

The attacker gains access to a valid mTLS certificate used for authentication with the Kubernetes API server. This certificate might be stored insecurely on a compromised node, leaked through a misconfigured application, or exposed through other vulnerabilities. Once in possession of the certificate and corresponding private key, the attacker can impersonate the associated user or service account and interact with the Kubernetes cluster.

### Potential Impact and Consequences

The impact of this vulnerability is severe. Depending on the permissions associated with the stolen certificate, the attacker could:

*   **Read sensitive data:** Access secrets, configuration maps, and other sensitive information stored in the cluster.
*   **Modify cluster resources:** Deploy, delete, and modify deployments, services, and other resources.
*   **Escalate privileges:** If the stolen certificate belongs to an administrator, the attacker could gain full control of the cluster.
*   **Denial of Service (DoS):** Disrupt or disable critical applications and services running in the cluster.
*   **Data Exfiltration:** Exfiltrate sensitive data stored in persistent volumes.

### Risk Level Assessment

**Critical**.  Successful exploitation grants unauthorized access to the Kubernetes API server, potentially leading to complete cluster compromise.

### Technical Explanation

The vulnerability exists due to the reliance on mTLS for authentication.  Kubernetes trusts certificates presented to it. If a certificate and its private key are compromised, the Kubernetes API server has no way to distinguish legitimate use from malicious use.  The attacker effectively becomes the legitimate user from the perspective of the API server.  This is exacerbated by insecure storage of certificates and weak access controls around these files.

### Prerequisites and Conditions Needed

*   Access to a Kubernetes cluster that uses mTLS authentication for the API server.
*   A user or service account certificate and corresponding private key that can be stolen or otherwise accessed. This could be achieved through:
    *   Compromising a node running services that use mTLS.
    *   Exploiting a vulnerability that allows reading files within a container.
    *   Finding leaked or misplaced certificates.
    *   Social engineering to trick legitimate users into revealing their certificates.
*   `kubectl` configured on the attacker's machine.

## 2. Validation and Exploitation Steps

**Assumptions:**

*   The attacker has obtained the certificate file (`user.crt`) and private key file (`user.key`) through some means (e.g., compromised pod, insecure storage).
*   The certificate is valid for authenticating against the Kubernetes API server.
*   We assume this user has access to create pods to validate the success. More specific resource access should be tested depending on the discovered certificate.

**Validation Phase:**

1.  **Configure kubectl to use the stolen certificate:**

    ```bash
    kubectl config set-credentials stolen-user --client-certificate=user.crt --client-key=user.key
    ```

    *   **Explanation:** This command configures `kubectl` to use the stolen certificate and key for authentication.  It creates a new credential named `stolen-user`.
    *   **Why:**  We need to tell `kubectl` how to authenticate using the stolen credentials.
    *   **Expected Output:**  No direct output.  `kubectl` stores the credential configuration.
    *   **Contribution:** Sets up the `kubectl` CLI to use the compromised credentials.
    *   **Variation:** The name `stolen-user` can be anything.

2.  **Create a new context that uses the stolen credentials:**

    ```bash
    kubectl config set-context stolen-context --cluster=$(kubectl config current-context | awk '{print $3}') --user=stolen-user --namespace=default
    ```

    *   **Explanation:** This command creates a new context named `stolen-context`. It uses the current cluster from the existing configuration and the `stolen-user` credentials created in the previous step.  It also sets the default namespace to `default`. Replace `default` with another namespace if appropriate for the compromised certificate's access.
    *   **Why:** A context combines cluster information, user credentials, and a default namespace.
    *   **Expected Output:** No direct output. `kubectl` stores the context configuration.
    *   **Contribution:** Configures the context to use the compromised credentials and cluster.
    *   **Variation:**  The cluster value is derived from the current context, ensuring we're connecting to the same cluster. `stolen-context` can be named anything.

3.  **Switch to the newly created context:**

    ```bash
    kubectl config use-context stolen-context
    ```

    *   **Explanation:** This command switches `kubectl` to use the `stolen-context`. All subsequent `kubectl` commands will now be executed as the user associated with the stolen certificate.
    *   **Why:**  To start using the stolen credentials for API calls.
    *   **Expected Output:** `Switched to context "stolen-context".`
    *   **Contribution:** Activates the compromised credentials for subsequent commands.

4.  **Verify the user associated with the stolen certificate:**

    ```bash
    kubectl auth whoami
    ```

     *   **Explanation:** This command authenticates against the API server and returns the username associated with the configured credentials (in this case, the stolen certificate).
     *   **Why:** To confirm the identity associated with the stolen credentials.
     *   **Expected Output:**  The username associated with the certificate. If this command fails with an "Unauthorized" error, the certificate may be invalid or lacking permissions.
     *   **Contribution:**  Verifies the identity we're impersonating.

5.  **Check access rights by attempting to list pods:**

    ```bash
    kubectl get pods
    ```

    *   **Explanation:** This command attempts to list pods in the default namespace using the stolen certificate.
    *   **Why:** To determine the permissions associated with the compromised credentials.
    *   **Expected Output:**
        *   If successful, the command will list the pods in the default namespace. This confirms that the user associated with the stolen certificate has read access to pods in the default namespace.
        *   If the user does not have permission, the command will return an error such as "Error from server (Forbidden): pods is forbidden: User \"stolen-user\" cannot list resource \"pods\" in API group \"\" in the namespace \"default\"". This indicates the extent of what actions are possible.
    *   **Contribution:** Validates access to specific resources and identifies the permissions associated with the stolen certificate.

**Exploitation Phase:**

Assuming the stolen certificate has sufficient permissions, the attacker can perform various actions. The following example demonstrates creating a pod:

6.  **Attempt to create a pod:**

    ```bash
    cat <<EOF | kubectl apply -f -
    apiVersion: v1
    kind: Pod
    metadata:
      name: vulnerable-pod
    spec:
      containers:
      - name: nginx
        image: nginx:latest
    EOF
    ```

    *   **Explanation:** This command attempts to create a new pod named "vulnerable-pod" using the `nginx:latest` image.
    *   **Why:** To exploit the compromised credentials by performing privileged actions.  Pod creation is a common privilege that allows further compromise.
    *   **Expected Output:**
        *   If successful, the command will create the pod. Output will show "pod/vulnerable-pod created".
        *   If the user does not have permission, the command will return an error such as "Error from server (Forbidden): pods is forbidden: User \"stolen-user\" cannot create resource \"pods\" in API group \"\" in the namespace \"default\"".
    *   **Contribution:** Demonstrates successful exploitation by creating a resource.
    *   **Variation:**  Can create any resource allowed by the certificate.

7.  **(If Pod Creation is successful) Verify the pod is running:**

    ```bash
    kubectl get pods vulnerable-pod
    ```

    *   **Explanation:** This command retrieves information about the pod named "vulnerable-pod".
    *   **Why:** To confirm that the pod was successfully created and is running.
    *   **Expected Output:** Information about the "vulnerable-pod" pod, including its status (e.g., Running). If the pod is not running, investigate the pod's logs using `kubectl logs vulnerable-pod` for errors.
    *   **Contribution:** Confirms successful pod creation as proof of exploitation.

**Further Exploitation (Depending on certificate permissions):**

*   **Access Secrets:** `kubectl get secrets`
*   **Read ConfigMaps:** `kubectl get configmaps`
*   **Create Services:** `kubectl create service clusterip ...`
*   **Modify Deployments:** `kubectl edit deployment ...`
*   **Scale Deployments:** `kubectl scale deployment ... --replicas=0`

## Remediation Recommendations

To mitigate the risk of mTLS certificate theft and impersonation, implement the following security measures:

*   **Secure Certificate Storage:** Store certificates and private keys in a secure location, such as a hardware security module (HSM) or a secrets management system.
*   **Limit Certificate Permissions:** Grant certificates only the necessary permissions to perform their intended tasks. Use Role-Based Access Control (RBAC) to define and enforce these permissions.
*   **Rotate Certificates Regularly:** Rotate certificates frequently to minimize the impact of a potential compromise.
*   **Monitor API Server Logs:** Monitor API server logs for suspicious activity, such as unexpected access patterns or attempts to perform unauthorized actions.
*   **Implement Audit Logging:**  Enable audit logging to track all API server requests and responses.
*   **Use Dedicated Service Accounts:** Avoid using the same certificate or service account for multiple applications.
*   **Implement Pod Security Policies (PSPs) or Pod Security Admission (PSA):**  These policies can help prevent containers from accessing sensitive files on the host.  (Note: PSPs are deprecated.)
*   **Principle of Least Privilege:**  Always grant users and service accounts only the minimum necessary permissions.
*   **Consider alternatives:** Evaluate alternative authentication methods like OIDC.
