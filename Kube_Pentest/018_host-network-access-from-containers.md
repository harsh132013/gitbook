
# Kubernetes Vulnerability: Host Network Access from Containers

## 1. Overview

This document details the vulnerability of containers gaining access to the host network namespace within a Kubernetes cluster. This vulnerability allows containers to bypass network isolation and potentially access services and resources on the host node itself, leading to significant security breaches.

### Attack Vector Description

An attacker who can deploy a pod configured to use the host network (`hostNetwork: true`) can potentially compromise the entire node and, by extension, the Kubernetes cluster. Once the pod is running in the host network namespace, it can interact with services bound to all interfaces on the host, bypass network policies, and potentially pivot to other containers or nodes within the cluster.

### Potential Impact and Consequences

*   **Node Compromise:**  Complete control over the compromised node.
*   **Data Breach:** Access to sensitive data stored on or accessible from the node.
*   **Privilege Escalation:**  Potential to escalate privileges within the cluster by exploiting vulnerabilities in services running on the host.
*   **Denial of Service:**  Disrupting services running on the host or other nodes in the cluster.
*   **Lateral Movement:**  Using the compromised node as a stepping stone to attack other resources in the network.

### Risk Level Assessment

**Critical**

This vulnerability is considered critical due to its potential for complete node compromise and significant impact on the entire Kubernetes cluster. It bypasses a fundamental security boundary, and exploitation is often straightforward.

### Technical Explanation

Kubernetes uses network namespaces to provide isolation between containers. By default, containers are isolated within their own network namespace, preventing them from directly accessing the host's network interfaces or services. However, when a pod is configured with `hostNetwork: true` in its pod specification, the container shares the host's network namespace. This bypasses the network isolation, granting the container direct access to the host's network interfaces, routing table, and all services bound to those interfaces. This configuration is often used in situations where direct network access is required, such as for CNI plugins or monitoring agents, but it introduces a significant security risk if not properly managed.

### Prerequisites and Conditions Needed

*   **Privilege to Deploy Pods:** An attacker needs sufficient privileges (e.g., `create` permission on pods) within a Kubernetes namespace to deploy a pod with `hostNetwork: true`. This often involves compromising a service account or exploiting other vulnerabilities to gain the necessary permissions.
*   **`hostNetwork: true` Configuration:** The pod specification must include the `hostNetwork: true` setting.
*   **Vulnerable Kubernetes Cluster:** The Kubernetes cluster must be running and accessible to the attacker.

## 2. Validation and Exploitation Steps

### Validation Phase: Determining if Host Network Access is Possible

**Step 1: Create a Pod Definition (pod.yaml) with `hostNetwork: true`**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: host-network-pod
spec:
  hostNetwork: true
  containers:
  - name: host-network-container
    image: alpine/curl # Using a small, readily available image with curl
    command: ["/bin/sh", "-c", "sleep infinity"]
```

*   **Explanation:** This YAML file defines a pod named `host-network-pod` with the `hostNetwork: true` setting.  It uses `alpine/curl` as a base image and keeps the pod running indefinitely using `sleep infinity`.
*   **Why:** This is the core of the validation process. We need a pod running in the host network to proceed.
*   **Expected Output:** A valid YAML file is created.
*   **Contribution:** Defines the pod that will be deployed to test for the vulnerability.

**Step 2: Attempt to Deploy the Pod**

```bash
kubectl apply -f pod.yaml
```

*   **Explanation:** This command attempts to deploy the pod defined in `pod.yaml` to the Kubernetes cluster.
*   **Why:** We are trying to create a pod that uses the host network. We need to verify whether we have permissions or policies in place that prevent this from happening.
*   **Expected Output:**
    *   **Successful Deployment:** If the pod is successfully created, the output will be similar to: `pod/host-network-pod created`
    *   **Authorization Error:** If you lack permissions, the output will be similar to: `Error from server (Forbidden): pods "host-network-pod" is forbidden: violates pod security policy: ...`
*   **Contribution:** Determines if you are able to create a pod that can potentially exploit the vulnerability.  If an error occurs, it may be due to restrictive Pod Security Policies (PSPs) or Pod Security Admission (PSA) preventing the use of `hostNetwork: true`.

**Step 3: (If deployment is successful) Exec into the Pod**

```bash
kubectl exec -it host-network-pod -- /bin/sh
```

*   **Explanation:** This command provides interactive access to the shell within the running pod.
*   **Why:**  We need to interact with the pod to verify if it truly has access to the host network.
*   **Expected Output:** A shell prompt inside the container, like: `/ #`
*   **Contribution:** Provides the environment where the host network access can be tested.

**Step 4: Verify Host Network Access by listing network interfaces**

```bash
ip addr
```

*   **Explanation:** This command lists the network interfaces as seen from inside the container.
*   **Why:** To confirm the pod has access to the host's network namespace, it should show the host's network interfaces (e.g., `eth0`, `wlan0`, etc.) rather than a container-specific interface.
*   **Expected Output:** The output should contain network interfaces belonging to the host, including the host's IP address and MAC address, not the isolated interface of a standard container.  Look for interfaces like `eth0`, `wlan0`, and `lo` (loopback) with IP addresses assigned to the host.
*   **Contribution:** Confirms whether the pod is indeed running in the host network.

**Step 5: Attempt to connect to localhost services on the host**

```bash
curl -v http://127.0.0.1:<port>
```

*   **Explanation:** This command attempts to connect to a service running on localhost on the host. Replace `<port>` with a commonly used port, like 80, 8080, 2379 (etcd). This assumes there is a service running on the host listening on that port.
*   **Why:** To verify that the pod can access services running on the host, bypassing network isolation.
*   **Expected Output:**
    *   **Successful Connection:**  If the host has a service listening on the port, the curl output should show a successful connection and the response from the service.
    *   **Connection Refused/Timeout:** If the host doesn't have a service listening on the port or the connection is blocked, the output will show an error such as "Connection refused" or "Timeout".
*   **Contribution:** Further confirms the extent of network access.  Success strongly indicates host network access.

### Exploitation Phase: Demonstrating the Impact

**Step 6: Identify potentially sensitive services running on the host**

This step requires reconnaissance.  Common ports to check include:

*   22 (SSH):  Potentially attempt to brute-force or exploit SSH vulnerabilities.
*   2379/2380 (etcd):  Access to etcd can lead to full cluster compromise.
*   10250 (kubelet API):  Unauthenticated access can allow for remote code execution on the node.
*   10255 (kubelet read-only port): Allows to retrieve sensitive information like pod and node details.
*   Any application server ports that might be running on the host to manage the kubernetes environment.

**Step 7: Exploit a service based on Step 6 results (Example: Accessing kubelet's read-only port)**

```bash
curl http://127.0.0.1:10255/pods
```

*   **Explanation:** This command attempts to access the kubelet's read-only API, which is often exposed on port 10255 without authentication.
*   **Why:** Access to the kubelet API can provide sensitive information about the pods running on the node.
*   **Expected Output:** A JSON response containing information about the pods running on the node, including their names, namespaces, labels, and container images.
*   **Contribution:** Demonstrates the ability to access sensitive information, which can then be used for further attacks.

**Step 8: (Optional) If etcd is accessible, retrieve secrets from etcd.**

This step is much more involved and depends greatly on cluster configuration. If etcd is accessible, using `etcdctl` to access keys will potentially retrieve Kubernetes secrets. This requires `etcdctl` to be installed inside the pod.

```bash
# Inside the pod
apt update && apt install -y etcd-client
etcdctl --endpoints=http://127.0.0.1:2379 get /kubernetes.io/secrets --prefix --keys-only
```

*   **Explanation:** Attempts to retrieve all keys from the `/kubernetes.io/secrets` prefix in etcd.
*   **Why:** Kubernetes stores secrets in etcd. If etcd is unauthenticated and accessible, this allows an attacker to retrieve all secrets in the cluster.
*   **Expected Output:** A list of keys to secrets.
*   **Contribution:** Direct access to secrets demonstrates a high-impact exploit.

### Potential Variations and Alternative Approaches

*   **Using `nmap` for Port Scanning:**  Install `nmap` in the pod and use it to scan the host's network for open ports.
*   **Checking `/proc/net/tcp`:**  Inspect the `/proc/net/tcp` file within the pod to identify listening ports on the host.
*   **Attempting to access other nodes via Host Network:** If the compromised node has access to other nodes via internal networking, pivot from the initial point of entry into other parts of the Kubernetes infrastructure.

## Remediation Recommendations

*   **Implement and Enforce Pod Security Policies (PSPs) or Pod Security Admission (PSA):** PSPs and PSA are crucial for restricting the capabilities of pods and preventing them from using `hostNetwork: true`. Configure PSPs/PSA to deny pods from using the host network unless explicitly authorized for specific, legitimate use cases.
*   **Role-Based Access Control (RBAC):**  Ensure that RBAC is properly configured to restrict who can create pods and which service accounts can be used. Limit the privileges of service accounts to the minimum necessary for their intended function.
*   **Network Policies:** Implement network policies to restrict network traffic between pods and namespaces, further isolating them from each other. This can help mitigate the impact of a compromised container, even if it has access to the host network.
*   **Audit Logging and Monitoring:**  Enable audit logging to track pod creation and configuration changes. Monitor for suspicious activity, such as pods being deployed with `hostNetwork: true` without proper authorization.
*   **Regular Vulnerability Scanning:**  Perform regular vulnerability scans of the Kubernetes cluster and the underlying infrastructure to identify and address potential security weaknesses.
*   **Principle of Least Privilege:** Adhere to the principle of least privilege by granting users and services only the minimum necessary permissions.
*   **Restrict etcd Access:** Properly secure etcd to prevent unauthorized access. Use mutual TLS authentication and limit access to only authorized Kubernetes components.
*   **Container Runtime Security:**  Use a security-focused container runtime like gVisor or Kata Containers to provide stronger isolation between containers and the host.

This comprehensive documentation provides a clear understanding of the "Host network access from containers" vulnerability in Kubernetes, including its potential impact, validation and exploitation steps, and remediation recommendations. It can be used by penetration testers to identify and assess this vulnerability and by administrators to secure their Kubernetes clusters.
