
# Kubernetes Scheduler Manipulation for Resource Exhaustion

## 1. Overview Section

### Attack Vector Description

An attacker can manipulate the Kubernetes scheduler to allocate excessive resources to a single node or a small subset of nodes, leading to resource exhaustion and denial of service (DoS). This is achieved by exploiting weaknesses in pod placement logic, affinity rules, tolerations, node selectors, and other scheduler configuration options. The attacker crafts malicious pod specifications that, when submitted to the Kubernetes API server, are scheduled in a way that overwhelms specific nodes, starving legitimate workloads of resources like CPU, memory, and disk I/O.

### Potential Impact and Consequences

*   **Denial of Service (DoS):** Overloading nodes leads to application unavailability and service disruption for users.
*   **Resource Starvation:** Legitimate workloads are deprived of resources, leading to degraded performance or failure.
*   **Data Loss:** In extreme cases, resource exhaustion can lead to data corruption or loss due to process crashes.
*   **Compromise of Node Integrity:** Overloaded nodes may become unstable and potentially vulnerable to further exploitation.
*   **Lateral Movement (Indirect):** An attacker could leverage an overloaded and potentially compromised node as a launchpad for further attacks within the cluster.

### Risk Level Assessment

**Critical/High**

The risk is considered High to Critical because successful exploitation can lead to a significant and immediate impact on the availability and performance of the Kubernetes cluster and the applications it hosts. The ease of exploitation depends on the cluster's configuration, but with appropriate permissions (or gained through compromised service accounts), the attack can be carried out relatively easily.

### Technical Explanation

The Kubernetes scheduler is responsible for placing pods onto suitable nodes based on resource requirements, constraints, and other factors. An attacker can exploit the following to influence the scheduler's decisions:

*   **Affinity and Anti-Affinity:**  Pods can be configured to prefer or avoid certain nodes based on labels. An attacker can use affinity rules to target specific nodes or to concentrate pods on a small set of nodes.
*   **Node Selectors:**  These allow pods to be scheduled only on nodes that have specific labels.  An attacker can combine this with affinity to target specific node(s).
*   **Tolerations and Taints:** Taints are applied to nodes to repel pods unless they have a corresponding toleration. An attacker can manipulate tolerations to bypass node taints and schedule pods on restricted nodes.
*   **Resource Requests and Limits:** While limits are important, the scheduler prioritizes satisfying the requests. By inflating the resource requests of pods without appropriate limits, an attacker can overwhelm the available resources on a node without immediately triggering OOMKills (Out-Of-Memory Killer).
*   **Priority Classes:** Higher priority classes allow pods to preempt lower priority pods. An attacker with access to create high-priority pods can displace critical applications.

This vulnerability exists due to the inherent complexity of the Kubernetes scheduler and the flexibility it provides for managing resource allocation. Misconfigurations and insufficient resource management practices can create opportunities for attackers to manipulate the scheduler for malicious purposes.

### Prerequisites and Conditions Needed

*   **Kubectl Access:** The attacker needs `kubectl` access to the Kubernetes cluster with sufficient permissions to create, modify, and delete pods and other Kubernetes objects.  Compromised service accounts can provide this.
*   **Knowledge of Cluster Topology:** Understanding the cluster's node configuration, labels, and resource availability helps the attacker craft effective pod specifications.  This information can be gathered through `kubectl get nodes` and `kubectl describe nodes`.
*   **Ability to create or modify pod specifications:** The attacker should be able to craft their own YAML files for deploying pods.
*   **(Optional) Access to create priority classes:** This will allow the attacker to create even higher-priority pods if necessary.

## 2. Validation and Exploitation Steps Section

The following steps demonstrate how to exploit the scheduler to exhaust resources on a targeted node.  Assume the target node is called `target-node-01` and has the label `node-type=worker`.

**Validation Phase:**

1.  **Identify the Target Node:**

    ```bash
    kubectl get nodes --show-labels
    ```

    *   **Explanation:** This command lists all nodes in the cluster along with their labels.
    *   **Why:** This helps identify nodes with specific characteristics (e.g., `node-type=worker`, `disk-type=ssd`) and determine a suitable target.
    *   **Expected Output:** A table displaying node names and labels. Look for a node to target, noting its name and labels. For example: `target-node-01   Ready    <age>    v1.27.4   node-type=worker`
    *   **Contribution:** Establishes the target of the attack.

2.  **Check Node Resource Capacity:**

    ```bash
    kubectl describe node target-node-01 | grep -E "Capacity:|Allocatable:"
    ```

    *   **Explanation:** This command retrieves detailed information about the target node and filters the output to show its resource capacity and allocatable resources.
    *   **Why:** This provides crucial information about how much resources we need to request from our pods to saturate the node.
    *   **Expected Output:** Displays the node's CPU, memory, and other resource capacities and the allocatable amount.  For example:
        ```
        Capacity:
         cpu:                4
         memory:             8154760Ki
        Allocatable:
         cpu:                3870m
         memory:             7947560Ki
        ```
    *   **Contribution:** Determines the resources available for exploitation.

**Exploitation Phase:**

3.  **Create a Malicious Pod Specification (resource-hog.yaml):**

    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: resource-hog
      labels:
        app: resource-hog
    spec:
      nodeSelector:
        node-type: worker # Target worker nodes
      containers:
      - name: resource-hog-container
        image: busybox # Lightweight image
        resources:
          requests:
            cpu: "1" # Request 1 CPU core
            memory: "2Gi" # Request 2GiB of memory
        command: ["/bin/sh", "-c", "while true; do echo 'Consuming resources...'; sleep 1; done"]
    ```

    *   **Explanation:** This YAML file defines a pod named `resource-hog` that targets nodes labeled `node-type=worker` using a `nodeSelector`. It requests 1 CPU core and 2GiB of memory. It uses a busybox image to run a simple loop that consumes resources.
    *   **Why:** This pod is designed to be easily schedulable on the targeted node and consume a significant amount of resources.  We request resources, not just limit them, so that the scheduler will allocate the resources as soon as possible.
    *   **Expected Output:** A YAML file defining the pod specification.

4.  **Deploy the Malicious Pod:**

    ```bash
    kubectl apply -f resource-hog.yaml
    ```

    *   **Explanation:** This command creates the pod in the Kubernetes cluster based on the YAML specification.
    *   **Why:** This submits the resource-hog pod to the cluster, prompting the scheduler to allocate it to a node matching the `nodeSelector`.
    *   **Expected Output:** `pod/resource-hog created`
    *   **Contribution:**  Instantiates the attacking pod.

5.  **Scale the Malicious Pod (optional but recommended for faster impact):**

    ```bash
    kubectl scale --replicas=3 pod/resource-hog
    ```

    *   **Explanation:**  This command increases the number of running `resource-hog` pods to 3.  Adjust the number of replicas based on the targeted node's capacity.
    *   **Why:** By creating multiple replicas, we can significantly increase the resource pressure on the targeted node, accelerating the resource exhaustion process.
    *   **Expected Output:** `pod/resource-hog scaled`
    *   **Contribution:** Amplifies the resource consumption.

6.  **Monitor Node Resource Usage:**

    ```bash
    kubectl top node target-node-01
    ```

    *   **Explanation:** This command displays the CPU and memory usage of the target node.
    *   **Why:** This allows you to observe the resource exhaustion in real-time.
    *   **Expected Output:** A table showing the CPU and memory usage of the node.  Expect to see the CPU and memory usage gradually increase as the resource-hog pods consume resources.  Eventually, the node may become unresponsive.  For example:
        ```
        NAME            CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%
        target-node-01   3680m        92%    7750Mi          95%
        ```
    *   **Contribution:**  Confirms the success of the attack.

7.  **Observe Pod Scheduling (Optional):**

    ```bash
    kubectl get pods -o wide
    ```

    *   **Explanation:** Lists all pods and shows the node on which they are running.
    *   **Why:** Verifies that the pods were indeed scheduled on the targeted node.
    *   **Expected Output:** A table showing pods and their assigned nodes.  Confirm that the `resource-hog` pods are running on `target-node-01`.

**Variations and Alternative Approaches:**

*   **DaemonSets:** Use a DaemonSet to deploy the `resource-hog` pod on every node in the cluster, maximizing the impact (more visible but also easier to detect).
*   **Persistent Volumes (PVs):** An attacker could claim excessive PVs to exhaust storage resources.
*   **Higher Resource Requests:** Increase the CPU and memory requests in the pod specification to accelerate resource exhaustion. Be careful not to request more than the node can offer; otherwise, the pod will never schedule.
*   **Anti-Affinity:** Deploy a high number of pods with anti-affinity rules to prevent them from being scheduled on the same node, spreading the resource consumption across the cluster.
*   **Priority Classes:** Exploit by setting higher priority class on the pods, ensuring they get scheduled over important system pods.
*   **Denial of Service via Log Flooding:**  Instead of CPU/Memory consumption, an attacker could fill up node disk space with excessive logging by pods.

**Remediation Recommendations:**

*   **Resource Quotas:** Implement resource quotas to limit the total amount of resources that can be requested by pods in a namespace.
*   **Limit Ranges:** Configure limit ranges to define default CPU and memory requests and limits for pods in a namespace.
*   **Pod Priority and Preemption:** Use pod priority and preemption to ensure that critical workloads are prioritized over less important ones.
*   **Node Taints and Tolerations:** Use node taints and tolerations to prevent pods from being scheduled on specific nodes unless they have the appropriate tolerations.
*   **Network Policies:** Enforce network policies to restrict network traffic between pods and prevent malicious pods from communicating with sensitive applications.
*   **Regular Monitoring and Auditing:** Implement robust monitoring and alerting to detect resource exhaustion and other suspicious activities. Regularly audit Kubernetes configurations and permissions to identify and address potential vulnerabilities.
*   **Principle of Least Privilege:** Grant users and service accounts only the minimum necessary permissions.
*   **Pod Security Standards (PSS):** Implement PSS to restrict the capabilities of pods and reduce the attack surface.
*   **Update Kubernetes:** Regularly update the Kubernetes control plane and worker nodes with the latest security patches.

This documentation provides a detailed guide on how to identify, validate, and exploit scheduler manipulation for resource exhaustion in Kubernetes. By understanding the attack vectors and implementing the recommended remediations, organizations can significantly improve the security posture of their Kubernetes clusters.
