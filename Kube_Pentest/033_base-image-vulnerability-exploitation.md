
# Kubernetes Penetration Testing: Base Image Vulnerability Exploitation

## 1. Overview Section

### Attack Vector Description

Exploiting vulnerabilities within the base image of a container deployed on Kubernetes represents a significant attack vector. Attackers can leverage known vulnerabilities in the underlying operating system packages, libraries, or pre-installed applications included in the base image to gain unauthorized access to the container runtime and potentially escalate privileges to the node level.

The attacker begins by identifying the base image used by the deployed container. Once identified, they search for known vulnerabilities associated with the image and its components using publicly available vulnerability databases (e.g., CVE databases, NVD). If exploitable vulnerabilities are found, the attacker crafts an exploit targeting that specific vulnerability within the container environment.

### Potential Impact and Consequences

Successful exploitation of a base image vulnerability can have severe consequences:

*   **Container Compromise:** Gain shell access to the container.
*   **Data Exfiltration:** Extract sensitive data stored within the container's file system.
*   **Lateral Movement:** Use the compromised container as a pivot point to attack other services within the Kubernetes cluster.
*   **Host Compromise:** Escalate privileges to gain access to the underlying node, compromising the entire node and potentially the entire cluster.
*   **Denial of Service (DoS):** Crash the container or the node, disrupting the application's availability.
*   **Malware Installation:** Install malicious software within the container or the node.

### Risk Level Assessment

**Critical/High**. The risk level is dependent on the severity of the vulnerability and the potential impact of a successful exploit. Vulnerabilities that allow for remote code execution (RCE) without authentication are considered critical. The ease of exploit and the business impact are also key factors.

### Technical Explanation of Why This Vulnerability Exists

Base images often contain outdated software packages and libraries due to:

*   **Lack of Regular Updates:** Base images may not be regularly updated with the latest security patches, leaving them vulnerable to known exploits.
*   **Unnecessary Components:** Images may include unnecessary software packages that introduce vulnerabilities but are not actually required by the application.
*   **Configuration Errors:** Improperly configured services within the base image can create exploitable attack surfaces.
*   **Developer negligence:** Developers may use untrusted, community maintained images.

These factors create opportunities for attackers to exploit known vulnerabilities that should have been patched or removed.

### Prerequisites and Conditions Needed

*   **Access to the Kubernetes cluster:** The attacker needs access to the Kubernetes cluster, either through compromised credentials or by exploiting an existing vulnerability in a different component.
*   **Container Identification:** The attacker needs to identify the specific container image being used by the target pod.
*   **Vulnerability Discovery:** The attacker needs to identify a known vulnerability in the base image or its components.
*   **Exploit Development or Availability:** The attacker needs a working exploit for the identified vulnerability. Publicly available exploits can sometimes be found.

## 2. Validation and Exploitation Steps Section

This section details a hypothetical scenario where a base image contains a vulnerable version of `curl`. Let's assume `curl < 7.85.0` has a known heap-based buffer overflow vulnerability (CVE-2022-32205).

**Validation Phase:**

1.  **Identify the Target Pod:**

    ```bash
    kubectl get pods -n <namespace>
    ```

    This command lists all pods in the specified namespace. We need to identify the pod that is running the container we want to target.  Replace `<namespace>` with the actual namespace.  The output will list the pods and their status. We will assume a target pod named `vulnerable-app-pod`.

    Expected Output:

    ```
    NAME                  READY   STATUS    RESTARTS   AGE
    vulnerable-app-pod   1/1     Running   0          10m
    ...
    ```

2.  **Identify the Container Image:**

    ```bash
    kubectl describe pod vulnerable-app-pod -n <namespace> | grep Image:
    ```

    This command describes the target pod and filters the output to show the container image used. We need this information to determine the base image. Replace `<namespace>` with the actual namespace.

    Expected Output:

    ```
           Image:          example.com/vulnerable-app:1.0
    ```

    Now we know the image is `example.com/vulnerable-app:1.0`.

3.  **Pull the Image (If Necessary) and Inspect Layers:**

    ```bash
    docker pull example.com/vulnerable-app:1.0
    docker history example.com/vulnerable-app:1.0
    ```

    This pulls the image locally (if not already present) and then shows the image's layers, providing clues to the base image used.  Examining the layers gives us insights into the underlying operating system and software included in the image.

    Expected Output (docker history example.com/vulnerable-app:1.0):

    ```
    IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT
    <image_id>     2 days ago   /bin/sh -c #(nop)  CMD ["/app/run"]            0B
    <image_id>     2 days ago   /bin/sh -c apt-get update && apt-get install -y curl  10MB
    <image_id>     2 days ago   /bin/sh -c #(nop) WORKDIR /app                   0B
    <image_id>     2 days ago   /bin/sh -c #(nop) COPY dir:xxx in /app           2MB
    <image_id>     2 days ago   /bin/sh -c #(nop)  USER app                     0B
    <image_id>     2 days ago   /bin/sh -c #(nop)  EXPOSE 8080                   0B
    <image_id>     2 days ago   /bin/sh -c #(nop)  ENTRYPOINT ["/app/entrypoint.sh"]   0B
    <image_id>     2 days ago   /bin/sh -c #(nop)  LABEL maintainer="Example Inc."   0B
    <image_id>     2 days ago   /bin/sh -c #(nop)  ENV APP_VERSION=1.0             0B
    <image_id>     2 days ago   /bin/sh -c #(nop) ADD file:xxx in /                 76.8MB
    <image_id>     3 days ago   /bin/sh -c #(nop)  CMD ["/bin/bash"]               0B
    <image_id>     3 days ago   /bin/sh -c #(nop) ADD file:xxx in /                 110MB
    <image_id>     3 days ago   /bin/sh -c #(nop) MAINTAINER Example               0B
    <image_id>     3 days ago   /bin/sh -c #(nop)  ENV APT_KEY_DONT_WARN_ON_D ...   0B
    <image_id>     3 days ago   /bin/sh -c apt-get update && apt-get install  ...   24.7MB
    <image_id>     3 days ago   /bin/sh -c #(nop)  ENV LANG=C.UTF-8                 0B
    <missing>      6 months ago  /bin/sh -c #(nop)  CMD ["/bin/bash"]               0B
    <missing>      6 months ago  /bin/sh -c #(nop) ADD file:xxx in /                 69.2MB
    ```

    The output shows that `curl` was installed, and potentially other packages as well. It also hints to an `apt-get update` and `install`, potentially indicating a Debian-based distribution.

4.  **Run the Image in a Container:**

    ```bash
    docker run -it --rm example.com/vulnerable-app:1.0 /bin/bash
    ```

    This runs the image in an interactive container and gives us a shell inside it. This allows us to directly interact with the container environment and verify the presence of `curl` and its version. The `--rm` flag ensures the container is automatically removed after exiting.

5.  **Check the `curl` Version:**

    ```bash
    curl --version
    ```

    Inside the container shell, run this command to check the installed version of `curl`.

    Expected Output:

    ```
    curl 7.81.0 (x86_64-pc-linux-gnu) libcurl/7.81.0 OpenSSL/1.1.1n zlib/1.2.11 brotli/1.0.9 zstd/1.4.8 libidn2/2.3.2 libpsl/0.21.0 (+libidn2) libssh/0.9.6/openssl/zlib nghttp2/1.43.0 librtmp/2.3
    Release-Date: 2021-10-27
    ```

    Since the `curl` version is 7.81.0, which is less than 7.85.0, the container is vulnerable to CVE-2022-32205.  We have now validated the vulnerability.

**Exploitation Phase:**

1.  **Exploit Preparation (Inside the Container):**

    We'll simulate the exploit. Since a detailed exploit is beyond this documentation's scope, we'll create a dummy file as a placeholder to represent successful exploitation. The real exploit would involve crafting a malicious `curl` request that triggers the heap-based buffer overflow and executes arbitrary code.

    ```bash
    touch /tmp/exploited
    ls -l /tmp/exploited
    ```

    This creates a file named `/tmp/exploited` inside the container.  A real exploit would likely write to a different location to signal a successful exploit and potentially execute arbitrary code.

2. **Escaping to the Node (Simulated):**

This step is highly dependent on the specific container runtime and configuration and may not always be possible. It often involves exploiting vulnerabilities in the container runtime or leveraging misconfigurations such as insecurely mounted volumes.

For this simulation, we'll assume a hypothetical scenario where the container has access to the node's `/proc` filesystem. This is a highly privileged scenario and shouldn't exist in a properly secured environment.

*   **Find the Host PID (Inside the Container):**

    ```bash
    ps -aux
    ```

    This lists all running processes inside the container. The container's PID 1 is usually the application process. This does *not* give us the host's PID.

    ```bash
    cat /proc/1/status | grep NSpid
    ```

    This command should provide insight on the NSpid, including PID within the host.

*   **Access the Host Filesystem (Simulated):**

    Assume `/hostfs` is mounted from the host's root filesystem. This would be a massive security misconfiguration.

    ```bash
    ls -l /hostfs/etc/shadow
    ```

    Attempting to list the host's shadow file would indicate successful access to the host filesystem. This would be highly problematic. In a real-world attack, the attacker would attempt to read sensitive files, install malware, or otherwise compromise the host system.

**Variations and Alternative Approaches:**

*   **Automated Vulnerability Scanning:** Tools like Trivy, Clair, and Anchore can automate the process of scanning container images for known vulnerabilities.
*   **Publicly Available Exploits:** Search for publicly available exploits for the identified vulnerability.  Resources like Exploit-DB and Metasploit can provide exploit code and guidance.
*   **Custom Exploit Development:** If a publicly available exploit is not available, the attacker may need to develop a custom exploit.
*   **Privilege Escalation:** After gaining initial access to the container, the attacker may attempt to escalate privileges using other vulnerabilities or misconfigurations.

**Remediation Recommendations:**

*   **Regularly Update Base Images:** Regularly update base images with the latest security patches. Implement a process for automatically rebuilding and redeploying containers when new patches are released.
*   **Minimize Image Size:** Reduce the size of the base image by removing unnecessary software packages and libraries. Use minimal base images like Alpine Linux or distroless images.
*   **Use a Vulnerability Scanner:** Integrate a vulnerability scanner into the CI/CD pipeline to automatically scan container images for known vulnerabilities.
*   **Implement Runtime Security:** Implement runtime security measures such as AppArmor or SELinux to restrict the capabilities of containers and prevent them from escaping the container runtime.
*   **Principle of Least Privilege:** Run containers with the minimum necessary privileges. Avoid running containers as root.
*   **Network Segmentation:** Segment the network to restrict the ability of compromised containers to access other services within the cluster.
*   **Monitor and Audit:** Implement comprehensive monitoring and auditing to detect and respond to suspicious activity.
*   **Immutable Infrastructure:** Adopt an immutable infrastructure approach, where containers are rebuilt and redeployed for every change, rather than being patched in place.
*   **Restrict Access to Node Filesystem:** Avoid mounting the node's filesystem into the container. If necessary, mount only the required directories and set appropriate permissions. Ensure you're not using privileged containers.

By addressing these vulnerabilities and implementing robust security measures, organizations can significantly reduce the risk of base image vulnerability exploitation in Kubernetes.
