
# Kubernetes IAM Role Assumption from Containers Vulnerability

## 1. Overview Section

**Attack Vector Description:**

This vulnerability allows an attacker, with code execution inside a container within a Kubernetes pod, to assume an AWS IAM role that is associated with the Kubernetes service account assigned to that pod. The attacker can then use the assumed role to perform actions within AWS with the permissions granted to the assumed role, effectively bypassing the intended container isolation and gaining elevated privileges. This attack leverages the Kubernetes Service Account Token Volume Projection feature and the IAM Roles for Service Accounts (IRSA) capability in AWS.

**Potential Impact and Consequences:**

Successful exploitation can lead to:

*   **Data Exfiltration:** Accessing and stealing sensitive data stored in AWS resources like S3 buckets, databases, and other services.
*   **Resource Manipulation:** Modifying or deleting critical AWS resources, causing disruption of services.
*   **Lateral Movement:** Using the compromised IAM role to access other AWS accounts or services, broadening the scope of the attack.
*   **Denial of Service (DoS):** Overloading or shutting down AWS resources.
*   **Privilege Escalation:** Gaining access to more privileged AWS roles, leading to complete control over the AWS environment.

**Risk Level Assessment:**

**Critical** - Due to the potential for complete compromise of the AWS environment and the ease of exploitation with container access.

**Technical Explanation:**

Kubernetes often uses Service Accounts to provide identities to Pods. When IAM Roles for Service Accounts (IRSA) are configured in AWS, the Kubernetes Service Account token is used to authenticate with AWS STS (Security Token Service) to assume an IAM role. If a container running in a pod with an associated service account is compromised, an attacker can extract the service account token and use it to assume the IAM role. The container's intended isolation is thus bypassed. The root cause is often overly permissive IAM roles granted to the Service Account, or a misconfiguration that allows unintended pods to access the role.

**Prerequisites and Conditions Needed:**

*   **Compromised Container:** The attacker needs to have gained code execution within a container running in a Kubernetes pod. This could be through a vulnerable application running inside the container (e.g., remote code execution vulnerability).
*   **IAM Role for Service Account (IRSA) Configuration:** An IAM role must be associated with the Kubernetes service account assigned to the compromised pod. This association is typically done using annotations on the Kubernetes Service Account object.
*   **AWS Credentials Absence (Preferred):**  Ideally, the container should *not* have pre-existing AWS credentials configured (e.g., through environment variables or a different configuration). This ensures the attacker is relying solely on the service account token for IAM role assumption.
*   **`aws` CLI or equivalent tool inside the container:**  The container needs to have tools available to interact with the AWS API, typically the `aws` CLI or similar SDK libraries.

## 2. Validation and Exploitation Steps Section

**Phase 1: Identifying the Service Account and Token**

This phase focuses on discovering the service account associated with the compromised pod and obtaining the service account token.

**Step 1: Identify the Kubernetes Service Account**

```bash
cat /var/run/secrets/kubernetes.io/serviceaccount/namespace
```

*   **Explanation:** This command reads the `namespace` file within the default service account token directory.
*   **Why:** Kubernetes mounts this directory into every container, providing metadata about the pod and its associated service account.  Knowing the namespace is essential.
*   **Expected Output:** The Kubernetes namespace the pod belongs to (e.g., `default`, `dev`, `production`).  Save this value for later use.
*   **Contributes to:** Identifying the namespace needed to locate the service account.

```bash
cat /var/run/secrets/kubernetes.io/serviceaccount/token
```

*   **Explanation:** This command reads the `token` file within the default service account token directory.
*   **Why:** This file contains the JWT (JSON Web Token) used for authenticating the pod with the Kubernetes API server. This token is also used by AWS STS when IRSA is configured.
*   **Expected Output:** A long, seemingly random string of characters representing the JWT. Copy this token.
*   **Contributes to:** Obtaining the critical JWT needed to assume the IAM role.

**Phase 2: Interacting with AWS STS**

This phase involves using the discovered service account token to interact with the AWS STS service to assume the IAM role.

**Step 2: Retrieve the Region**

```bash
curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone | sed 's/.$//'
```

*   **Explanation:** This command queries the AWS instance metadata service to determine the AWS region where the Kubernetes cluster is running.
*   **Why:** The AWS region is needed to configure the `aws` CLI and interact with AWS services.
*   **Expected Output:** The AWS region (e.g., `us-east-1`, `eu-west-2`). Save this value.
*   **Contributes to:** Setting up the AWS CLI for subsequent commands.

```bash
export AWS_REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone | sed 's/.$//')
echo $AWS_REGION
```

*   **Explanation:** Sets the `AWS_REGION` environment variable with the retrieved AWS region.  The `echo` command confirms the value.
*   **Why:**  The `aws` CLI will use this environment variable to determine which AWS region to communicate with.
*   **Expected Output:**  Prints the AWS region to the console.
*   **Contributes to:**  Configuring the `aws` CLI.

**Step 3: Using the STS AssumeRoleWithWebIdentity**

```bash
aws sts assume-role-with-web-identity \
    --role-arn "arn:aws:iam::<ACCOUNT_ID>:role/<ROLE_NAME>" \
    --role-session-name "pentest-session" \
    --web-identity-token file:///var/run/secrets/kubernetes.io/serviceaccount/token \
    --duration-seconds 3600 \
    --region $AWS_REGION
```

*   **Explanation:** This command calls the `sts assume-role-with-web-identity` API to assume the IAM role associated with the service account.
*   **Why:** This is the core step in exploiting the vulnerability.  It leverages the service account token as a "web identity" to authenticate with AWS STS and obtain temporary credentials.
*   **Replace `<ACCOUNT_ID>` with the AWS account ID where the IAM role is defined.**
*   **Replace `<ROLE_NAME>` with the name of the IAM role associated with the Service Account.** This can often be found as annotations on the ServiceAccount resource itself, or by inspecting the IAM Role configuration.
*   **`--role-session-name`:** Provides a session name for the assumed role, which can be helpful for auditing and tracking.
*   **`--duration-seconds`:** Specifies the duration of the assumed role session (max 3600 seconds = 1 hour).
*   **`--region`:**  Specifies the AWS Region.
*   **Expected Output:** A JSON payload containing the temporary AWS credentials (AccessKeyId, SecretAccessKey, SessionToken) and metadata about the assumed role.
*   **Contributes to:** Obtaining temporary AWS credentials for the assumed IAM role.

**Step 4: Configure AWS CLI with Assumed Role Credentials**

```bash
export AWS_ACCESS_KEY_ID="<ACCESS_KEY_ID>"
export AWS_SECRET_ACCESS_KEY="<SECRET_ACCESS_KEY>"
export AWS_SESSION_TOKEN="<SESSION_TOKEN>"
```

*   **Explanation:**  This command sets the AWS environment variables with the temporary credentials obtained from the `assume-role-with-web-identity` API call.
*   **Why:** The AWS CLI uses these environment variables to authenticate subsequent requests to AWS services.
*   **Replace `<ACCESS_KEY_ID>`, `<SECRET_ACCESS_KEY>`, and `<SESSION_TOKEN>` with the values from the JSON output of the previous command.**
*   **Expected Output:**  No direct output. These commands set environment variables.
*   **Contributes to:** Configuring the AWS CLI to use the assumed role's credentials.

**Phase 3: Validate the Assumed Role and Exploit**

This phase validates that the role has been successfully assumed and explores the permissions granted to the role to identify potential exploitation opportunities.

**Step 5: Verify Assumed Identity**

```bash
aws sts get-caller-identity
```

*   **Explanation:** This command calls the `sts get-caller-identity` API to retrieve information about the current identity.
*   **Why:** This confirms that the AWS CLI is now using the assumed role's credentials. The output will show the ARN of the assumed role.
*   **Expected Output:** A JSON payload containing the `UserId`, `Account`, and `Arn` of the assumed role.  The `Arn` should match the ARN of the role you expected to assume.
*   **Contributes to:** Verifying that the IAM role has been successfully assumed.

**Step 6: Discover Available Permissions**

This step requires exploring the permissions granted to the assumed role. The exact commands will depend on the targeted AWS services and resources. Here are some examples:

```bash
aws s3 ls s3://<BUCKET_NAME>
```

*   **Explanation:** Lists the contents of an S3 bucket.
*   **Why:** To check if the assumed role has read access to the S3 bucket.
*   **Replace `<BUCKET_NAME>` with the name of an existing S3 bucket.** You may need to enumerate S3 buckets if you don't know which ones exist.
*   **Expected Output:** A list of objects within the bucket, or an error message indicating lack of permissions.

```bash
aws ec2 describe-instances
```

*   **Explanation:** Describes EC2 instances in the region.
*   **Why:** To check if the assumed role has read access to EC2 instances.
*   **Expected Output:** A JSON payload containing details of the EC2 instances in the region, or an error message indicating lack of permissions.

```bash
aws iam get-role --role-name <ROLE_NAME>
```

*   **Explanation:**  Retrieves details about the IAM role's permissions policy.
*   **Why:** Helps determine the actions and resources the role is allowed to access, guiding further exploitation efforts.
*   **Replace `<ROLE_NAME>` with the name of the IAM role you assumed.**
*   **Expected Output:**  JSON output describing the role, including its attached policies and trust relationship.

**Step 7: Exploit Vulnerable Permissions**

Based on the discovered permissions, attempt to exploit the vulnerability. Examples include:

*   **Data Exfiltration:** If the role has read access to S3 buckets, download sensitive data.
*   **Resource Manipulation:** If the role has write access to EC2 instances, start, stop, or terminate instances.
*   **Privilege Escalation:** If the role has the ability to assume other roles, assume those roles to gain higher privileges.  This is often possible if the role has `sts:AssumeRole` permission on other roles.

**Example: Assuming another role (Privilege Escalation)**

Assuming the role `pentest-role` has permissions to assume role `admin-role`:

```bash
aws sts assume-role --role-arn "arn:aws:iam::<ACCOUNT_ID>:role/admin-role" --role-session-name "escalated-session"
```

*   **Explanation:**  Assumes the `admin-role` using the credentials of `pentest-role`.
*   **Replace `<ACCOUNT_ID>` with the AWS account ID where the `admin-role` is defined.**
*   **Expected Output:**  A new set of temporary credentials for the `admin-role`.

**Phase 4: Remediation**

**Remediation Recommendations:**

*   **Principle of Least Privilege:**  Grant the IAM role only the *minimum* necessary permissions required for the application to function.  Avoid wildcard permissions (e.g., `s3:*`) and restrict access to specific resources.
*   **Restrict Service Account Usage:**  Only associate IAM roles with service accounts that *actually* need them.  If a pod doesn't require AWS access, don't assign it a service account with an associated IAM role.
*   **Kubernetes Network Policies:**  Implement network policies to restrict network traffic between pods, limiting the impact of a compromised container.
*   **Pod Security Policies/Pod Security Admission:** Enforce security policies on pods to prevent them from running with excessive privileges (e.g., prevent running as root).  Consider using the new Pod Security Admission controller.
*   **Monitor Service Account Usage:**  Monitor the usage of service accounts and IAM roles to detect suspicious activity.
*   **Regularly Audit IAM Permissions:**  Periodically review and audit the permissions granted to IAM roles and service accounts to identify and remediate any overly permissive configurations.  Tools like AWS IAM Access Analyzer can help with this.
*   **Container Image Security:**  Regularly scan container images for vulnerabilities and ensure they are built with the latest security patches.
*   **Least Privilege within Containers:** Even if a container is compromised, try to limit what the attacker can do within the container. Use techniques like running processes as non-root users, using Linux capabilities effectively, and leveraging seccomp profiles.
*   **Rotate Kubernetes Service Account Tokens:** While more complex, consider implementing a system for rotating Kubernetes service account tokens on a regular basis. This can mitigate the impact of a compromised token.

This documentation provides a comprehensive guide to understanding, validating, and exploiting the IAM role assumption from containers vulnerability in Kubernetes. Remember to always obtain explicit permission before performing penetration testing activities.
