
# Kubernetes Pod-to-Pod Lateral Movement via Network Policies Vulnerability

## 1. Overview Section

**Attack Vector Description:**

An attacker who has compromised a pod within a Kubernetes cluster may be able to move laterally to other pods if network policies are not properly configured or are overly permissive.  This attack leverages the default Kubernetes networking model, which, in the absence of network policies, allows all pods to communicate freely. If an attacker gains a foothold (e.g., through a vulnerable application within a pod), they can scan the network for other vulnerable services or access sensitive data within other pods. This is a critical vulnerability that can lead to widespread data compromise and system control.

**Potential Impact and Consequences:**

*   **Data Breach:** Access to sensitive data stored or processed by other pods.
*   **Privilege Escalation:** Gaining access to pods with higher privileges, potentially leading to cluster-wide control.
*   **Service Disruption:** Compromising critical services and causing denial-of-service.
*   **Malware Propagation:** Using compromised pods to spread malware or other malicious software within the cluster.
*   **Compliance Violations:** Failure to comply with security standards like PCI DSS, HIPAA, or GDPR.

**Risk Level Assessment:**

*   **Critical** - If the cluster is exposed to the internet or untrusted networks and sensitive data is present.
*   **High** - If the cluster is internal but contains critical systems or sensitive data.
*   **Medium** - If the cluster is internal, contains less sensitive data, and strong authentication is in place.

**Technical Explanation:**

Kubernetes Network Policies are used to control the traffic flow between pods.  By default, if no network policies are defined, all pods can communicate with each other without restriction. This open communication allows an attacker who has compromised one pod to easily access other pods, potentially exploiting vulnerabilities or accessing sensitive data. Insufficient or misconfigured network policies create a security gap that enables lateral movement.  Specifically:

*   **Lack of Network Policies:** No policies defined, allowing unrestricted communication.
*   **Overly Permissive Policies:** Policies that allow broad communication based on labels or namespaces without considering specific pod roles or service requirements.
*   **Misconfigured Egress Policies:** Policies that don't restrict outbound traffic from compromised pods, enabling communication with external resources or other internal pods.

**Prerequisites and Conditions Needed:**

*   **Compromised Pod:** The attacker must have gained access to at least one pod within the Kubernetes cluster. This could be achieved through a vulnerable application, misconfigured service, or other means.
*   **kubectl Access:** The attacker needs access to the `kubectl` command-line tool or a similar interface to interact with the Kubernetes API from within the compromised pod.  This is often available by default or easily obtainable.  Alternative tools like `curl` can also be used if `kubectl` is not directly available, provided the pod has the necessary service account credentials and network access to the Kubernetes API server.
*   **No or Insufficient Network Policies:**  A lack of restrictive network policies or policies that are too broad is essential for this attack to succeed.
*   **Network Connectivity:**  The compromised pod must have network connectivity to other pods within the cluster.

## 2. Validation and Exploitation Steps Section

**Phase 1: Validation - Discovering Network Policies and Cluster Information**

**Step 1: Determine Cluster Name & Context**

```bash
kubectl config current-context
```

*   **Explanation:** This command retrieves the current Kubernetes context, which identifies the cluster you are interacting with.  Knowing the context is important for properly targeting subsequent commands.
*   **Why:** To ensure commands are executed against the intended Kubernetes cluster.
*   **Expected Output:** The name of the current Kubernetes context (e.g., `minikube`, `gke_my-project_us-central1-a_my-cluster`).
*   **Validation:** Confirm the context is the target cluster.

**Step 2: List Network Policies**

```bash
kubectl get networkpolicies --all-namespaces
```

*   **Explanation:** This command lists all network policies defined in the cluster across all namespaces. It helps to identify if any network policies are present and what they allow or deny.
*   **Why:** To understand the current network policy configuration and identify potential weaknesses.
*   **Expected Output:** A table showing the names, namespaces, and selectors of existing network policies. If no policies are defined, it will indicate `No resources found`.
*   **Validation:** If the output shows "No resources found", it indicates a complete lack of network policies, making the cluster highly vulnerable. If policies are found, examine them for overly permissive rules.

**Step 3: List Services in the Cluster**

```bash
kubectl get svc --all-namespaces
```

*   **Explanation:** This command lists all services in the cluster, including their names, namespaces, types, and associated ports. This helps to identify potential targets for lateral movement.
*   **Why:** To enumerate potential targets accessible from the compromised pod.
*   **Expected Output:** A table listing the services running in the cluster, including their names, namespaces, and ports.
*   **Validation:** This helps to identify potential targets based on their names, namespaces, and ports (e.g., a database service in a different namespace).

**Step 4: Identify Pods in the Cluster**

```bash
kubectl get pods --all-namespaces -o wide
```

*   **Explanation:** This command lists all pods in the cluster across all namespaces, including their names, namespaces, IP addresses, nodes, and other useful information.
*   **Why:** To identify target pods based on IP address for network scans, and to determine which nodes they are running on for more targeted exploitation.
*   **Expected Output:** A table listing the pods running in the cluster, including their names, namespaces, IPs, and nodes.
*   **Validation:** Provides the IP addresses required to attempt connection to the pods.

**Phase 2: Exploitation - Lateral Movement**

**Step 5: Exec into Compromised Pod**

(Assuming you have a compromised pod named `compromised-pod` in namespace `default`)

```bash
kubectl exec -it compromised-pod -n default -- /bin/sh
```

*   **Explanation:** This command opens an interactive shell session within the compromised pod. You are now operating within the pod's environment.
*   **Why:** To execute commands from the compromised pod and attempt to reach other pods.
*   **Expected Output:** A shell prompt within the `compromised-pod`.
*   **Validation:** The shell prompt indicates successful access to the pod's environment.

**Step 6: Install `netcat` or `nmap` (if not already present)**

```bash
# If using Debian/Ubuntu based image
apt-get update && apt-get install -y netcat

# If using Alpine based image
apk add --no-cache netcat-openbsd

# or nmap
apt-get update && apt-get install -y nmap
```

*   **Explanation:** Installs network utilities for port scanning and connection attempts.  These tools might not be pre-installed in all container images. `netcat` is a simple tool for making TCP/UDP connections, while `nmap` is a more powerful port scanner.
*   **Why:** To test network connectivity to other pods within the cluster.
*   **Expected Output:** Successful installation of the package.  If the package manager fails, you may need to update the package list or use a different package manager based on the container's base image.
*   **Validation:** The package manager should indicate a successful installation.

**Step 7: Scan for Open Ports on a Target Pod**

(Assuming a target pod with IP `10.244.1.5`)

```bash
# Using netcat to check for port 80
nc -vz 10.244.1.5 80

#Using Nmap to check for open ports (faster but more resources)
nmap -p 1-100 10.244.1.5
```

*   **Explanation:** These commands attempt to connect to port 80 (HTTP) or scan ports from 1 to 100 on the target pod using `netcat` and `nmap` respectively. `nc -vz` attempts a connection to a specific port and reports success or failure.  `nmap` performs a more comprehensive port scan.
*   **Why:** To identify open ports on the target pod, indicating potentially vulnerable services.
*   **Expected Output:**
    *   `netcat`: "Connection to 10.244.1.5 80 port [tcp/http] succeeded!" (if port 80 is open)
    *   `nmap`: A list of open ports and their associated services (if any).
*   **Validation:**  A successful connection or a listing of open ports confirms network connectivity to the target pod.

**Step 8: Attempt to Access the Service on the Target Pod**

(Assuming port 80 is open on `10.244.1.5`)

```bash
# If curl is available
curl http://10.244.1.5

# If curl is not available, use netcat to send a basic HTTP request
echo -e "GET / HTTP/1.0\n\n" | nc 10.244.1.5 80
```

*   **Explanation:** These commands attempt to retrieve the HTTP content from the target pod on port 80. `curl` is a common tool for making HTTP requests.  If `curl` is not available, `netcat` can be used to send a basic HTTP request.
*   **Why:** To verify that the attacker can access the service running on the target pod and potentially exploit vulnerabilities.
*   **Expected Output:**
    *   `curl`: The HTML content returned by the web server running on the target pod.
    *   `netcat`: Similar output to `curl`, showing the HTTP response headers and content.
*   **Validation:** Receiving an HTTP response confirms successful communication with the service.  The content of the response may reveal sensitive information or vulnerabilities.

**Step 9: (Advanced) Check for the Kubernetes Service Account Token**

```bash
ls /var/run/secrets/kubernetes.io/serviceaccount/token
cat /var/run/secrets/kubernetes.io/serviceaccount/token
```

*   **Explanation:**  Kubernetes automatically mounts a service account token into each pod.  If this token is exposed or inadvertently used, the attacker can use it to authenticate to the Kubernetes API and perform actions within the cluster. This would be extremely dangerous, escalating the threat.
*   **Why:** To retrieve the service account token, if present, for use in further exploitation or privilege escalation.
*   **Expected Output:**
    *   `ls`:  The output should show `/var/run/secrets/kubernetes.io/serviceaccount/token` indicating the file exists.
    *   `cat`: The content of the token file, which is a long string of characters.
*   **Validation:** The presence of the token and the ability to read its content indicate a serious vulnerability. If the service account has elevated privileges, the attacker could control the entire cluster.

**Step 10: (Advanced) Use the Token to Interact with the Kubernetes API Server (if token retrieved in Step 9)**

```bash
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
APISERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)

# Get Pods in the current namespace
curl -s --header "Authorization: Bearer $TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt $APISERVER/api/v1/namespaces/$NAMESPACE/pods | jq .
```

*   **Explanation:**  This command uses the service account token (retrieved in the previous step) to authenticate to the Kubernetes API server and list pods in the current namespace.  `kubectl config view` extracts the API server address. `jq` is a JSON processor to format the output (requires installation within the pod).
*   **Why:** To demonstrate the ability to interact with the Kubernetes API using the compromised pod's service account token. This is a significant privilege escalation and allows for further attacks.
*   **Expected Output:** A JSON list of pods in the current namespace returned by the Kubernetes API server.
*   **Validation:** A successful API response confirms the ability to authenticate using the token. If the service account has sufficient permissions, the attacker could perform a wide range of actions, including creating, deleting, and modifying resources in the cluster.

**Remediation Recommendations:**

1.  **Implement and Enforce Network Policies:** Define network policies to restrict traffic flow between pods based on the principle of least privilege.  Default deny policies for both ingress and egress should be implemented. Carefully define allowed communication paths.
2.  **Regularly Review Network Policies:** Continuously monitor and review network policies to ensure they are up-to-date and accurately reflect the required communication patterns.
3.  **Principle of Least Privilege:** Minimize the permissions granted to service accounts. Avoid granting unnecessary permissions to pods. Use role-based access control (RBAC) to restrict access to Kubernetes resources.
4.  **Secure Container Images:** Use minimal base images for containers to reduce the attack surface. Regularly scan container images for vulnerabilities.
5.  **Network Segmentation:** Segment the network into different zones based on sensitivity and criticality. Use network policies to restrict communication between zones.
6.  **Intrusion Detection and Prevention:** Implement intrusion detection and prevention systems to monitor network traffic for malicious activity.
7.  **Rotate Service Account Tokens:**  While Kubernetes automatically handles token rotation to a certain degree, monitor token usage and consider manual rotation in specific scenarios or in response to a security incident.
8.  **Audit Logging:**  Enable audit logging on the Kubernetes API server to track API requests and identify suspicious activity.
9.  **Container Runtime Security:** Utilize container runtime security tools and techniques to isolate containers and prevent privilege escalation.
10. **Disable Unnecessary Services:** Disable or remove any unnecessary services or ports from pods to minimize the attack surface.

By following these steps, a penetration tester can effectively identify and exploit pod-to-pod lateral movement vulnerabilities caused by inadequate network policies in Kubernetes. The remediation recommendations can then be applied to harden the cluster and prevent such attacks.
